

typedef struct InstructionSingle{
	enum InstructionTypeID {
		I_ERR_ = 0, // I_ERR_ is not an instruction, if it is encountered, the compiler should terminate execution
		I_NOP_,
		I_PU1_,
		I_PU2_,
		I_PUA1,
		I_PUA2,
		I_POP1,
		I_POP2,
		I_BL1_,
		I_RL1_,
		I_RL2_,
		I_CALL,
		I_RET_,
		I_STPA,
		I_STPS,
		I_STWN,
		I_STRN,
		I_STWV,
		I_STRV,
		I_ALOC,
		I_ALCR,
		I_STOF,
		I_AJMP,
		I_CJMP,
		I_JJMP,
		I_JTEN,
		I_JEND,
		I_MOV_,
		I_AND_,
		I_OR__,
		I_XOR_,
		I_SSUB,
		I_ADDN,
		I_SUBN,
		I_SUBC,
		I_MULS,
		I_MULL,
		I_DIVM,
		I_SHFT,
		I_BSWP,
		I_MWWN,
		I_MRWN,
		I_MWWV,
		I_MRWV,
		I_MWBN,
		I_MRBN,
		I_MWBV,
		I_MRBV,
		I_LABL,
		I_PHIS,
		I_PHIE,
		I_FCST,
		I_FCEN,
		I_D32U,
		I_R32U,
		I_D32S,
		I_R32S,
		I_D64U,
		I_R64U,
		I_D64S,
		I_R64S,
		I_LAD0,
		I_LAD1,
		I_LAD2,
		I_LAD3,
		I_LAD4,
		I_LAD5,
		I_LSU0,
		I_LSU3,
		I_LSU4,
		I_LSU5,
		I_LMU3,
		I_LMU4,
		I_LMU5,
		I_LDI4,
		I_LDI5,
		I_LLS6,
		I_LLS7,
		I_LRS6,
		I_LRS7,
		I_SYRB,
		I_SYRW,
		I_SYRD,
		I_SYRQ,
		I_SYRE,
		
		I_SYCB,
		I_SYCW,
		I_SYCD,
		I_SYCL,
		I_SYW0,
		I_SYW1,
		I_SYW2,
		I_SYW3,
		I_SYW4,
		I_SYW5,
		I_SYW6,
		I_SYW7,
		I_SYW8,
		I_SYW9,
		I_SBLW,
		I_SBRW,
		I_SYD0,
		I_SYD1,
		I_SYD2,
		I_SYD3,
		I_SYD4,
		I_SYD5,
		I_SYD6,
		I_SYD7,
		I_SYD8,
		I_SYD9,
		I_SBLD,
		I_SBRD,
		I_SYQ0,
		I_SYQ1,
		I_SYQ2,
		I_SYQ3,
		I_SYQ4,
		I_SYQ5,
		I_SYQ6,
		I_SYQ7,
		I_SYQ8,
		I_SYQ9,
		I_SBLQ,
		I_SBRQ,
		I_SCBW,
		I_SCWD,
		I_SCZD,
		I_SCDQ,
		I_SCZQ,
		I_SCQD,
		I_SCDW,
		I_SCWB,
		I_SCDB,
		I_SCQB,
		
		// the following should not be encontered by the instruction optimizer
		
		I_NSNB,
		I_ZNXB,
		I_BYTE,
		I_WORD,
		I_DWRD,
		I_SYDB,
		I_SYDW,
		I_SYDD,
		I_SYDQ,
		I_SYDE,
		
		I_DEPL, // I_DEPL is used for when a depth limit is reached for peephole optimization templates, it is not an instruction
		I_PEPH, // used in peephole optimization templates for poping or pushing a value
		
		I_STPI, // for placing initializer offsets. Is converted to I_STPA after the variable's local offset is calculated.
		
		I_LOFF, // used temporarily by listed initializers to indicate an offset of the data that comes next
		
		I_INSR // this is the insert placeholder for core entries, it is not an instruction. It uses the 'B1' struct in the 'arg' union
	} id;
	union {
		struct {
			uint8_t a_0;
		} B1;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			
			bool mem_flag_upper_byte_unused; // [for stack memory access instructions only] used to flag stack memory word accesses as having the upper or lower byte in memory being unused
			bool mem_flag_lower_byte_unused;
		} B2;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint8_t a_2;
			
			bool mem_flag_upper_byte_unused; // [for non-stack memory access instructions only] used to flag non-stack memory word accesses as having the upper or lower byte in memory being unused
			bool mem_flag_lower_byte_unused;
		} B3;
		struct {
			uint16_t a_1;
			uint8_t a_0;
		} BW;
		struct {
			uint32_t a_2;
			uint8_t a_0;
			uint8_t a_1;
		} BBD;
		struct {
			uint32_t a_2;
			uint16_t a_1;
			uint8_t a_0;
		} BWD;
		struct {
			uint16_t a_0;
		} W;
		struct {
			uint32_t a_0;
			
			bool mark; // [for use on LABL only] used in the optimizer to avoid infinite loops
		} D;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint8_t a_2;
			uint8_t a_3;
		} B4;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint8_t a_2;
			uint8_t a_3;
			uint8_t a_4;
		} B5;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint8_t a_2;
			uint8_t a_3;
			uint8_t a_4;
			uint8_t a_5;
		} B6;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint8_t a_2;
			uint8_t a_3;
			uint8_t a_4;
			uint8_t a_5;
			uint8_t a_6;
			uint8_t a_7;
		} B8;
	} arg;
} InstructionSingle;

typedef struct CompressedInstructionBuffer{
	uint8_t* byteCode;
	uint32_t allocLen;
} CompressedInstructionBuffer;


// InstructionBuffer has initializers (that are generated by the python script), so don't change it around
typedef struct InstructionBuffer{
	InstructionSingle* buffer;
	uint32_t numberOfSlotsAllocated;
	uint32_t numberOfSlotsTaken;
} InstructionBuffer;



#ifdef INCLUDE_BACKEND
uint32_t backendInstructionSize(const InstructionSingle* IS){
	switch (IS->id){
		case I_SYDB:
		case I_BYTE:
		return 1;
		case I_RET_:
		case I_PU1_:
		case I_PU2_:
		case I_PUA1:
		case I_PUA2:
		case I_POP1:
		case I_POP2:
		case I_CALL:
		case I_MULS:
		case I_MULL:
		case I_DIVM:
		case I_SHFT:
		case I_BSWP:
		case I_MOV_:
		case I_AND_:
		case I_OR__:
		case I_XOR_:
		case I_ADDN:
		case I_SSUB:
		case I_SUBN:
		case I_SUBC:
		case I_MWBN:
		case I_MRBN:
		case I_MWBV:
		case I_MRBV:
		case I_MWWN:
		case I_MRWN:
		case I_MWWV:
		case I_MRWV:
		case I_STWN:
		case I_STRN:
		case I_STWV:
		case I_STRV:
		case I_CJMP:
		case I_JJMP:
		case I_AJMP:
		case I_SYRB:
		case I_BL1_:
		case I_SYDW:
		case I_WORD:
		return 2;
		case I_SYRW:
		case I_RL1_:
		case I_STPS:
		case I_JTEN:
		case I_SYDD:
		case I_DWRD:
		return 4;
		case I_STPA:
		case I_ALOC:
		case I_LAD0:
		case I_LAD1:
		case I_LAD2:
		case I_LSU0:
		return 6;
		case I_RL2_:
		case I_SYRD:
		case I_SYDQ:
		return 8;
		case I_LAD3:
		return 10;
		case I_D32U:
		case I_R32U:
		case I_D32S:
		case I_R32S:
		case I_D64U:
		case I_D64S:
		case I_R64U:
		case I_R64S:
		case I_LAD4:
		case I_LAD5:
		case I_LSU4:
		case I_LSU5:
		case I_LMU4:
		case I_LMU5:
		case I_LDI4:
		case I_LDI5:
		case I_LLS6:
		case I_LLS7:
		case I_LRS6:
		case I_LRS7:
		return 14;
		case I_SYRQ:
		return 16;
		
		case I_ALCR:return 4u+(((unsigned)IS->arg.BW.a_1&0xFF00u)!=0u)*2u;
		case I_STOF:return 8u+(((unsigned)IS->arg.BW.a_1&0xFF00u)!=0u)*2u;
		case I_ZNXB:return IS->arg.D.a_0;
		
		case I_LSU3:
		case I_LMU3:
		assert(false);// backend not ready for those instructions yet
		default:;
	}
	return 0;
}

uint8_t decompressInstruction(const uint8_t* byteCode,InstructionSingle* IS_parent);

uint32_t backendInstructionSizeFromByteCode(const uint8_t* byteCode){
	InstructionSingle IS;
	IS.id=byteCode[0];
	if (IS.id==I_ALCR | IS.id==I_STOF | IS.id==I_ZNXB){
		decompressInstruction(byteCode,&IS);
	}
	switch (IS.id){
		case I_SYDB:
		case I_BYTE:
		return 1;
		case I_RET_:
		case I_PU1_:
		case I_PU2_:
		case I_PUA1:
		case I_PUA2:
		case I_POP1:
		case I_POP2:
		case I_CALL:
		case I_MULS:
		case I_MULL:
		case I_DIVM:
		case I_SHFT:
		case I_BSWP:
		case I_MOV_:
		case I_AND_:
		case I_OR__:
		case I_XOR_:
		case I_ADDN:
		case I_SSUB:
		case I_SUBN:
		case I_SUBC:
		case I_MWBN:
		case I_MRBN:
		case I_MWBV:
		case I_MRBV:
		case I_MWWN:
		case I_MRWN:
		case I_MWWV:
		case I_MRWV:
		case I_STWN:
		case I_STRN:
		case I_STWV:
		case I_STRV:
		case I_CJMP:
		case I_JJMP:
		case I_AJMP:
		case I_SYRB:
		case I_BL1_:
		case I_SYDW:
		case I_WORD:
		return 2;
		case I_SYRW:
		case I_RL1_:
		case I_STPS:
		case I_JTEN:
		case I_SYDD:
		case I_DWRD:
		return 4;
		case I_STPA:
		case I_ALOC:
		case I_LAD0:
		case I_LAD1:
		case I_LAD2:
		case I_LSU0:
		return 6;
		case I_RL2_:
		case I_SYRD:
		case I_SYDQ:
		return 8;
		case I_LAD3:
		return 10;
		case I_D32U:
		case I_R32U:
		case I_D32S:
		case I_R32S:
		case I_D64U:
		case I_D64S:
		case I_R64U:
		case I_R64S:
		case I_LAD4:
		case I_LAD5:
		case I_LSU4:
		case I_LSU5:
		case I_LMU4:
		case I_LMU5:
		case I_LDI4:
		case I_LDI5:
		case I_LLS6:
		case I_LLS7:
		case I_LRS6:
		case I_LRS7:
		return 14;
		case I_SYRQ:
		return 16;
		
		case I_ALCR:return 4u+(((unsigned)IS.arg.BW.a_1&0xFF00u)!=0u)*2u;
		case I_STOF:return 8u+(((unsigned)IS.arg.BW.a_1&0xFF00u)!=0u)*2u;
		case I_ZNXB:return IS.arg.D.a_0;
		
		case I_LSU3:
		case I_LMU3:
		assert(false);// backend not ready for those instructions yet
		default:;
	}
	return 0;
}


// symVal includes symbolic calculations,JTEN, and location of related label for things like D32U
void backendInstructionWrite(uint8_t** byte,uint32_t symVal,uint16_t func_stack_size,uint8_t func_stack_initial,const InstructionSingle IS){
	uint8_t b0=((unsigned)IS.arg.B2.a_0&0xFu)|(((unsigned)IS.arg.B2.a_1&0xFu)<<4);
	uint8_t b1=((unsigned)IS.arg.B3.a_0&0xFu)|(((unsigned)IS.arg.B3.a_1&0xFu)<<4);
	uint8_t b2=(unsigned)IS.arg.B3.a_2&0xFu;
	uint16_t w;
	InstructionSingle bh;// backend helper (to compose instructions from here)
	switch (IS.id){
		case I_NOP_:
		case I_JEND:
		case I_SYRE:
		case I_SYDE:
		case I_SYCB:
		case I_SYCW:
		case I_SYCD:
		case I_SYCL:
		case I_SYW0:
		case I_SYW1:
		case I_SYW2:
		case I_SYW3:
		case I_SYW4:
		case I_SYW5:
		case I_SYW6:
		case I_SYW7:
		case I_SYW8:
		case I_SYW9:
		case I_SBLW:
		case I_SBRW:
		case I_SYD0:
		case I_SYD1:
		case I_SYD2:
		case I_SYD3:
		case I_SYD4:
		case I_SYD5:
		case I_SYD6:
		case I_SYD7:
		case I_SYD8:
		case I_SYD9:
		case I_SBLD:
		case I_SBRD:
		case I_SYQ0:
		case I_SYQ1:
		case I_SYQ2:
		case I_SYQ3:
		case I_SYQ4:
		case I_SYQ5:
		case I_SYQ6:
		case I_SYQ7:
		case I_SYQ8:
		case I_SYQ9:
		case I_SBLQ:
		case I_SBRQ:
		case I_SCBW:
		case I_SCWD:
		case I_SCZD:
		case I_SCDQ:
		case I_SCZQ:
		case I_SCQD:
		case I_SCDW:
		case I_SCWB:
		case I_SCDB:
		case I_SCQB:
		case I_PHIS:
		case I_PHIE:
		case I_FCST:
		case I_FCEN:
		case I_NSNB:
		case I_LABL:
		return;
		
		case I_SYDB:*((*byte)++)=symVal;return;
		case I_BYTE:*((*byte)++)=IS.arg.B1.a_0;return;
		
		case I_PU1_:case I_PUA1:*((*byte)++)=(unsigned)IS.arg.B1.a_0&0xFu;*((*byte)++)=0xF0;return;
		case I_POP1:*((*byte)++)=IS.arg.B1.a_0&0xFu;*((*byte)++)=0xF2;return;
		case I_PU2_:case I_PUA2:*((*byte)++)=b0;*((*byte)++)=0xF1;return;
		case I_POP2:*((*byte)++)=b0;*((*byte)++)=0xF3;return;
		case I_MOV_:*((*byte)++)=b0;*((*byte)++)=0xF4;return;
		case I_BSWP:*((*byte)++)=b0;*((*byte)++)=0xF5;return;
		case I_SHFT:*((*byte)++)=b0;*((*byte)++)=0xF6;return;
		case I_MULS:*((*byte)++)=b0;*((*byte)++)=0xF7;return;
		case I_MULL:*((*byte)++)=b0;*((*byte)++)=0xF8;return;
		case I_DIVM:*((*byte)++)=b0;*((*byte)++)=0xF9;return;
		case I_CALL:*((*byte)++)=b0;*((*byte)++)=0xFA;return;
		case I_MRBN:case I_MRBV:*((*byte)++)=b0;*((*byte)++)=0xFC;return;
		case I_MWBN:case I_MWBV:*((*byte)++)=b0;*((*byte)++)=0xFD;return;
		case I_JJMP:*((*byte)++)=((unsigned)IS.arg.BBD.a_0&0xFu)|(((unsigned)IS.arg.BBD.a_1&0xFu)<<4);*((*byte)++)=0xFE;return;
		case I_AJMP:*((*byte)++)=b0;*((*byte)++)=0xFE;return;
		case I_RET_:*((*byte)++)=0;*((*byte)++)=0xFB;return;
		case I_AND_:*((*byte)++)=b1;*((*byte)++)=0x40|b2;return;
		case I_OR__:*((*byte)++)=b1;*((*byte)++)=0x50|b2;return;
		case I_XOR_:*((*byte)++)=b1;*((*byte)++)=0x60|b2;return;
		case I_SSUB:*((*byte)++)=b1;*((*byte)++)=0x70|b2;return;
		case I_MRWN:case I_MRWV:*((*byte)++)=b1;*((*byte)++)=0x80|b2;return;
		case I_MWWN:case I_MWWV:*((*byte)++)=b1;*((*byte)++)=0x90|b2;return;
		case I_ADDN:*((*byte)++)=b1;*((*byte)++)=0xA0|b2;return;
		case I_SUBN:*((*byte)++)=b1;*((*byte)++)=0xC0|b2;return;
		case I_SUBC:*((*byte)++)=b1;*((*byte)++)=0xD0|b2;return;
		case I_CJMP:*((*byte)++)=b1;*((*byte)++)=0xE0|b2;return;
		
		case I_SYRB:*((*byte)++)=(((unsigned)symVal&0xFu)<<4)|((unsigned)IS.arg.B1.a_0&0xFu);*((*byte)++)=(((unsigned)symVal>>4)&0xFu);return;
		case I_BL1_:*((*byte)++)=(((unsigned)IS.arg.B2.a_1&0xFu)<<4)|((unsigned)IS.arg.B2.a_0&0xFu);*((*byte)++)=(((unsigned)IS.arg.B2.a_1>>4)&0xFu);return;
		case I_STRN:case I_STRV:*((*byte)++)=(((unsigned)IS.arg.B2.a_1&0xFu)<<4)|((unsigned)IS.arg.B2.a_0&0xFu);*((*byte)++)=0x20u|(((unsigned)IS.arg.B2.a_1>>4)&0xFu);return;
		case I_STWN:case I_STWV:*((*byte)++)=(((unsigned)IS.arg.B2.a_1&0xFu)<<4)|((unsigned)IS.arg.B2.a_0&0xFu);*((*byte)++)=0x30u|(((unsigned)IS.arg.B2.a_1>>4)&0xFu);return;
		
		case I_SYDW:*((*byte)++)=symVal;*((*byte)++)=(unsigned)symVal>>8;return;
		case I_WORD:*((*byte)++)=IS.arg.W.a_0;*((*byte)++)=(unsigned)IS.arg.W.a_0>>8;return;
		
		case I_SYRW:
		*((*byte)++)=(((unsigned)symVal&0xFu)<<4)|((unsigned)IS.arg.B1.a_0&0xFu);*((*byte)++)=(((unsigned)symVal>>4)&0xFu);
		*((*byte)++)=(((unsigned)symVal>>4)&0xF0u)|((unsigned)IS.arg.B1.a_0&0xFu);*((*byte)++)=0x10u|(((unsigned)symVal>>12)&0xFu);
		return;
		case I_RL1_:
		*((*byte)++)=(((unsigned)IS.arg.BW.a_1&0xFu)<<4)|((unsigned)IS.arg.BW.a_0&0xFu);*((*byte)++)=(((unsigned)IS.arg.BW.a_1>>4)&0xFu);
		*((*byte)++)=(((unsigned)IS.arg.BW.a_1>>4)&0xF0u)|((unsigned)IS.arg.BW.a_0&0xFu);*((*byte)++)=0x10u|(((unsigned)IS.arg.BW.a_1>>12)&0xFu);
		return;
		case I_STPS:
		w=func_stack_size-IS.arg.BW.a_1;
		*((*byte)++)=(((unsigned)w&0xFu)<<4)|((unsigned)IS.arg.BW.a_0&0xFu);*((*byte)++)=(((unsigned)w>>4)&0xFu);
		*((*byte)++)=(((unsigned)IS.arg.BW.a_0<<4)&0xF0u)|((unsigned)IS.arg.BW.a_0&0xFu);*((*byte)++)=0xA1;
		return;
		
		case I_JTEN:case I_SYDD:*((*byte)++)=symVal;*((*byte)++)=(unsigned)symVal>>8;*((*byte)++)=symVal>>16;*((*byte)++)=symVal>>24;return;
		case I_DWRD:*((*byte)++)=IS.arg.D.a_0;*((*byte)++)=(unsigned)IS.arg.D.a_0>>8;*((*byte)++)=IS.arg.D.a_0>>16;*((*byte)++)=IS.arg.D.a_0>>24;return;
		return;
		case I_STPA:
		w=func_stack_size-IS.arg.BW.a_1;
		*((*byte)++)=(((unsigned)w&0xFu)<<4)|((unsigned)IS.arg.BW.a_0&0xFu);*((*byte)++)=(((unsigned)w>>4)&0xFu);
		*((*byte)++)=(((unsigned)w>>4)&0xF0u)|((unsigned)IS.arg.BW.a_0&0xFu);*((*byte)++)=0x10u|(((unsigned)w>>12)&0xFu);
		*((*byte)++)=(((unsigned)IS.arg.BW.a_0<<4)&0xF0u)|((unsigned)IS.arg.BW.a_0&0xFu);*((*byte)++)=0xA1;
		return;
		case I_ALOC:
		w=func_stack_size-func_stack_initial;
		*((*byte)++)=(((unsigned)w&0xFu)<<4)|1u;*((*byte)++)=(((unsigned)w>>4)&0xFu);
		*((*byte)++)=(((unsigned)w>>4)&0xF0u)|1u;*((*byte)++)=0x10u|(((unsigned)w>>12)&0xFu);
		*((*byte)++)=1;*((*byte)++)=0xFF;
		return;
		case I_RL2_:
		*((*byte)++)=(((unsigned)IS.arg.BBD.a_2&0xFu)<<4)|((unsigned)IS.arg.BBD.a_0&0xFu);*((*byte)++)=(((unsigned)IS.arg.BBD.a_2>>4)&0xFu);
		*((*byte)++)=(((unsigned)IS.arg.BBD.a_2>>4)&0xF0u)|((unsigned)IS.arg.BBD.a_0&0xFu);*((*byte)++)=0x10u|(((unsigned)IS.arg.BBD.a_2>>12)&0xFu);
		w=IS.arg.BBD.a_2>>16;
		*((*byte)++)=(((unsigned)w&0xFu)<<4)|((unsigned)IS.arg.BBD.a_1&0xFu);*((*byte)++)=(((unsigned)w>>4)&0xFu);
		*((*byte)++)=(((unsigned)w>>4)&0xF0u)|((unsigned)IS.arg.BBD.a_1&0xFu);*((*byte)++)=0x10u|(((unsigned)w>>12)&0xFu);
		return;
		case I_SYRD:
		*((*byte)++)=(((unsigned)symVal&0xFu)<<4)|((unsigned)IS.arg.B2.a_0&0xFu);*((*byte)++)=(((unsigned)symVal>>4)&0xFu);
		*((*byte)++)=(((unsigned)symVal>>4)&0xF0u)|((unsigned)IS.arg.B2.a_0&0xFu);*((*byte)++)=0x10u|(((unsigned)symVal>>12)&0xFu);
		w=symVal>>16;
		*((*byte)++)=(((unsigned)w&0xFu)<<4)|((unsigned)IS.arg.B2.a_1&0xFu);*((*byte)++)=(((unsigned)w>>4)&0xFu);
		*((*byte)++)=(((unsigned)w>>4)&0xF0u)|((unsigned)IS.arg.B2.a_1&0xFu);*((*byte)++)=0x10u|(((unsigned)w>>12)&0xFu);
		return;
		case I_D32U:
		case I_R32U:
		case I_D32S:
		case I_R32S:
		*((*byte)++)=0xA;*((*byte)++)=0;*((*byte)++)=0xA;*((*byte)++)=0xF0;
		
		*((*byte)++)=(((unsigned)symVal&0xFu)<<4)|0xAu;*((*byte)++)=(((unsigned)symVal>>4)&0xFu);
		*((*byte)++)=(((unsigned)symVal>>4)&0xF0u)|0xAu;*((*byte)++)=0x10u|(((unsigned)symVal>>12)&0xFu);
		w=symVal>>16;
		*((*byte)++)=(((unsigned)w&0xFu)<<4)|0xBu;*((*byte)++)=(((unsigned)w>>4)&0xFu);
		*((*byte)++)=(((unsigned)w>>4)&0xF0u)|0xBu;*((*byte)++)=0x10u|(((unsigned)w>>12)&0xFu);
		
		*((*byte)++)=0xBA;*((*byte)++)=0xFA;
		return;
		case I_D64U:
		case I_R64U:
		case I_D64S:
		case I_R64S:
		case I_LAD4:
		case I_LAD5:
		case I_LSU4:
		case I_LSU5:
		case I_LMU4:
		case I_LMU5:
		case I_LDI4:
		case I_LDI5:
		case I_LLS6:
		case I_LLS7:
		case I_LRS6:
		case I_LRS7:
		*((*byte)++)=0x2;*((*byte)++)=0;*((*byte)++)=0x2;*((*byte)++)=0xF0;
		
		*((*byte)++)=(((unsigned)symVal&0xFu)<<4)|0x2u;*((*byte)++)=(((unsigned)symVal>>4)&0xFu);
		*((*byte)++)=(((unsigned)symVal>>4)&0xF0u)|0x2u;*((*byte)++)=0x10u|(((unsigned)symVal>>12)&0xFu);
		w=symVal>>16;
		*((*byte)++)=(((unsigned)w&0xFu)<<4)|0x3u;*((*byte)++)=(((unsigned)w>>4)&0xFu);
		*((*byte)++)=(((unsigned)w>>4)&0xF0u)|0x3u;*((*byte)++)=0x10u|(((unsigned)w>>12)&0xFu);
		
		*((*byte)++)=0x32;*((*byte)++)=0xFA;
		return;
		case I_ALCR:
		*((*byte)++)=(((unsigned)IS.arg.BW.a_1&0xFu)<<4)|((unsigned)IS.arg.BW.a_0&0xFu);*((*byte)++)=(((unsigned)IS.arg.BW.a_1>>4)&0xFu);
		if ((((unsigned)IS.arg. BW.a_1&0xFF00u)!=0u)){
			*((*byte)++)=(((unsigned)IS.arg.BW.a_1>>4)&0xF0u)|((unsigned)IS.arg.BW.a_0&0xFu);*((*byte)++)=0x10u|(((unsigned)IS.arg.BW.a_1>>12)&0xFu);
		}
		*((*byte)++)=(unsigned)IS.arg.BW.a_0&0xFu;*((*byte)++)=0xFF;
		return;
		case I_STOF:
		*((*byte)++)=0xFu;*((*byte)++)=0;
		*((*byte)++)=0xFu;*((*byte)++)=0xFF;
		w=(unsigned)IS.arg.BW.a_0&0xFu;
		*((*byte)++)=(((unsigned)IS.arg.BW.a_1&0xFu)<<4)|((unsigned)w);*((*byte)++)=(((unsigned)IS.arg.BW.a_1>>4)&0xFu);
		if (((unsigned)IS.arg.BW.a_1&0xFF00u)!=0u){
			*((*byte)++)=(((unsigned)IS.arg.BW.a_1>>4)&0xF0u)|((unsigned)w);*((*byte)++)=0x10u|(((unsigned)IS.arg.BW.a_1>>12)&0xFu);
		}
		*((*byte)++)=(unsigned)w|((unsigned)w<<4);*((*byte)++)=0xAFu;
		return;
		case I_ZNXB:
		for (uint32_t i=0;i<IS.arg.D.a_0;i++){
			*((*byte)++)=0;
		}
		return;
		case I_LAD0:
		*((*byte)++)=0xFu;*((*byte)++)=0;
		*((*byte)++)=(((unsigned)IS.arg.B6.a_2&0xFu)<<4)|((unsigned)IS.arg.B6.a_0&0xFu);*((*byte)++)=0xB0u|((unsigned)IS.arg.B6.a_4&0xFu);
		*((*byte)++)=(((unsigned)IS.arg.B6.a_3&0xFu)<<4)|((unsigned)IS.arg.B6.a_1&0xFu);*((*byte)++)=0xB0u|((unsigned)IS.arg.B6.a_5&0xFu);
		//Explanation: *((*byte)++)=(((unsigned) r1 &0xFu)<<4)|((unsigned) r0 &0xFu);*((*byte)++)=0xB0u|((unsigned) r2 &0xFu);
		return;
		case I_LAD1:
		*((*byte)++)=0xFu;*((*byte)++)=0;
		*((*byte)++)=(((unsigned)IS.arg.B5.a_2&0xFu)<<4)|((unsigned)IS.arg.B5.a_0&0xFu);*((*byte)++)=0xB0u|((unsigned)IS.arg.B5.a_4&0xFu);
		bh.id=I_ADDN;
		bh.arg.B3.a_0=IS.arg.B5.a_1;
		bh.arg.B3.a_1=IS.arg.B5.a_3;
		bh.arg.B3.a_2=15;
		backendInstructionWrite(byte,0,0,0,bh);
		return;
		case I_LAD2:
		*((*byte)++)=0xFu;*((*byte)++)=0;
		*((*byte)++)=(((unsigned)IS.arg.B4.a_2&0xFu)<<4)|((unsigned)IS.arg.B4.a_0&0xFu);*((*byte)++)=0xB0u|((unsigned)IS.arg.B4.a_3&0xFu);
		bh.id=I_MOV_;
		bh.arg.B2.a_0=IS.arg.B4.a_1;
		bh.arg.B2.a_1=15;
		backendInstructionWrite(byte,0,0,0,bh);
		return;
		case I_LSU0:
		bh.id=I_BL1_;
		bh.arg.B2.a_0=15;
		bh.arg.B2.a_1=1;
		backendInstructionWrite(byte,0,0,0,bh);
		bh.id=I_SSUB;
		bh.arg.B3.a_0=15;
		bh.arg.B3.a_1=IS.arg.B4.a_0;
		bh.arg.B3.a_2=IS.arg.B4.a_2;
		backendInstructionWrite(byte,0,0,0,bh);
		bh.id=I_SSUB;
		bh.arg.B3.a_0=15;
		bh.arg.B3.a_1=IS.arg.B4.a_1;
		bh.arg.B3.a_2=IS.arg.B4.a_3;
		backendInstructionWrite(byte,0,0,0,bh);
		return;
		case I_LAD3:
		*((*byte)++)=0xFu;*((*byte)++)=0;
		*((*byte)++)=(((unsigned)IS.arg.B8.a_0&0xFu)<<4)|((unsigned)IS.arg.B8.a_0&0xFu);*((*byte)++)=0xB0u|((unsigned)IS.arg.B8.a_4&0xFu);
		*((*byte)++)=(((unsigned)IS.arg.B8.a_1&0xFu)<<4)|((unsigned)IS.arg.B8.a_1&0xFu);*((*byte)++)=0xB0u|((unsigned)IS.arg.B8.a_5&0xFu);
		*((*byte)++)=(((unsigned)IS.arg.B8.a_2&0xFu)<<4)|((unsigned)IS.arg.B8.a_2&0xFu);*((*byte)++)=0xB0u|((unsigned)IS.arg.B8.a_6&0xFu);
		*((*byte)++)=(((unsigned)IS.arg.B8.a_3&0xFu)<<4)|((unsigned)IS.arg.B8.a_3&0xFu);*((*byte)++)=0xB0u|((unsigned)IS.arg.B8.a_7&0xFu);
		return;
		default:;
	}
	assert(false); // invalid operator id
	exit(1);
}
#endif //ifdef INCLUDE_BACKEND


// for compressed instruction buffers
uint8_t instructionContentCatagory(enum InstructionTypeID id){
	switch (id){
		case I_NOP_:
		return 0;
		case I_FCEN:
		case I_RET_:
		case I_ALOC:
		case I_D32U:
		case I_R32U:
		case I_D32S:
		case I_R32S:
		case I_D64U:
		case I_R64U:
		case I_D64S:
		case I_R64S:
		case I_LAD4:
		case I_LAD5:
		case I_LSU4:
		case I_LSU5:
		case I_LMU4:
		case I_LMU5:
		case I_LDI4:
		case I_LDI5:
		case I_LLS6:
		case I_LLS7:
		case I_LRS6:
		case I_LRS7:
		case I_JEND:
		case I_SYRE:
		case I_SYDB:
		case I_SYDW:
		case I_SYDD:
		case I_SYDQ:
		case I_SYDE:
		case I_SYW0:
		case I_SYW1:
		case I_SYW2:
		case I_SYW3:
		case I_SYW4:
		case I_SYW5:
		case I_SYW6:
		case I_SYW7:
		case I_SYW8:
		case I_SYW9:
		case I_SBLW:
		case I_SBRW:
		case I_SYD0:
		case I_SYD1:
		case I_SYD2:
		case I_SYD3:
		case I_SYD4:
		case I_SYD5:
		case I_SYD6:
		case I_SYD7:
		case I_SYD8:
		case I_SYD9:
		case I_SBLD:
		case I_SBRD:
		case I_SYQ0:
		case I_SYQ1:
		case I_SYQ2:
		case I_SYQ3:
		case I_SYQ4:
		case I_SYQ5:
		case I_SYQ6:
		case I_SYQ7:
		case I_SYQ8:
		case I_SYQ9:
		case I_SBLQ:
		case I_SBRQ:
		case I_SCBW:
		case I_SCWD:
		case I_SCZD:
		case I_SCDQ:
		case I_SCZQ:
		case I_SCQD:
		case I_SCDW:
		case I_SCWB:
		case I_SCDB:
		case I_SCQB:
		return 1;
		case I_PU1_:
		case I_PUA1:
		case I_POP1:
		case I_SYRB:
		case I_SYRW:
		case I_PHIS:
		case I_PHIE:
		return 2;
		case I_BYTE:
		case I_SYCB:
		return 3;
		case I_PU2_:
		case I_PUA2:
		case I_POP2:
		case I_CALL:
		case I_AJMP:
		case I_MULS:
		case I_MULL:
		case I_DIVM:
		case I_SHFT:
		case I_BSWP:
		case I_MWBN:
		case I_MRBN:
		case I_MWBV:
		case I_MRBV:
		case I_MOV_:
		case I_SYRD:
		return 4;
		case I_AND_:
		case I_OR__:
		case I_XOR_:
		case I_SSUB:
		case I_ADDN:
		case I_SUBN:
		case I_SUBC:
		case I_MWWN:
		case I_MRWN:
		case I_MWWV:
		case I_MRWV:
		case I_CJMP:
		return 5;
		case I_BL1_:
		case I_STWN:
		case I_STRN:
		case I_STWV:
		case I_STRV:
		return 6;
		case I_WORD:
		case I_SYCW:
		return 7;
		case I_RL1_:
		case I_ALCR:
		case I_STPA:
		case I_STPS:
		case I_STOF:
		return 8;
		case I_LABL:
		case I_JTEN:
		case I_SYCD:
		case I_SYCL:
		case I_DWRD:
		case I_NSNB:
		case I_ZNXB:
		return 9;
		case I_RL2_:
		case I_JJMP:
		return 10;
		case I_FCST:
		return 11;
		case I_LAD2:
		case I_SYRQ:
		case I_LSU0:
		return 12;
		case I_LAD1:
		return 13;
		case I_LAD0:
		return 14;
		case I_LAD3:
		case I_LSU3:
		case I_LMU3:
		return 15;
		default:;
	}
	assert(false); // invalid operator id
	exit(1);
}

#ifndef IGNORE_NONBACKEND
#define INIT_INSTRUCTION_BUFFER_SIZE 1024

void initInstructionBuffer(InstructionBuffer* ib){
	memset(ib,0,sizeof(InstructionBuffer));
	ib->numberOfSlotsAllocated = INIT_INSTRUCTION_BUFFER_SIZE;
	ib->buffer = cosmic_malloc(ib->numberOfSlotsAllocated*sizeof(InstructionSingle));
}

void destroyInstructionBuffer(InstructionBuffer* ib){
	cosmic_free(ib->buffer);
	ib->buffer = NULL;
	ib->numberOfSlotsTaken = 0;
	ib->numberOfSlotsAllocated = 0;
}

void addInstruction(InstructionBuffer* ib, const InstructionSingle instructionSingle){
	if (ib->numberOfSlotsTaken>=ib->numberOfSlotsAllocated){
		assert(ib->numberOfSlotsAllocated!=0); // Cannot add instruction to destroyed instruction buffer
		ib->numberOfSlotsAllocated*=2;
		ib->buffer = cosmic_realloc(ib->buffer,ib->numberOfSlotsAllocated*sizeof(InstructionSingle));
	}
	ib->buffer[ib->numberOfSlotsTaken++]=instructionSingle;
}
#endif // #ifndef IGNORE_NONBACKEND

struct {
	const char* corruptionErrorMessage;
	FILE* binaryFile;
} binaryFileLoadState = {0};

// gets the next character from the currently open binary fle and ensures it is not EOF
uint8_t binaryFile_noEOF_fgetc(){
	int v;
	if ((v=fgetc(binaryFileLoadState.binaryFile))==EOF) err_10_1_(binaryFileLoadState.corruptionErrorMessage);
	return (uint8_t)v;
}

// ensures the next call to fgetc on the currently open binary file will give the EOF
void binaryFile_isEOF_fgetc(){
	if (fgetc(binaryFileLoadState.binaryFile)!=EOF) err_10_1_(binaryFileLoadState.corruptionErrorMessage);
}


// returns the delta
uint8_t decompressInstruction(const uint8_t* byteCode,InstructionSingle* IS_parent){
	uint8_t delta=0;
	InstructionSingle IS;
	switch (instructionContentCatagory(IS.id=byteCode[0])){
		case 0:
		delta=0;
		break;
		case 1:
		delta=1;
		break;
		case 2:
		IS.arg.B1.a_0=byteCode[1]&15;
		delta=2;
		break;
		case 3:
		IS.arg.B1.a_0=byteCode[1];
		delta=2;
		break;
		case 4:
		IS.arg.B2.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B2.a_1=(unsigned)byteCode[1]/16u;
		delta=2;
		break;
		case 5:
		IS.arg.B3.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B3.a_1=(unsigned)byteCode[1]/16u;
		IS.arg.B3.a_2=(unsigned)byteCode[2]&15u;
		delta=3;
		break;
		case 6:
		IS.arg.B2.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B2.a_1=byteCode[2];
		delta=3;
		break;
		case 7:
		IS.arg.W.a_0=(unsigned)byteCode[1]|(unsigned)byteCode[2]*256u;
		delta=3;
		break;
		case 8:
		IS.arg.BW.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.BW.a_1=(unsigned)byteCode[2]|(unsigned)byteCode[3]*256u;
		delta=4;
		break;
		case 9:
		IS.arg.D.a_0=
		(uint32_t)((unsigned)byteCode[1]|(unsigned)byteCode[2]*256u)|
		(uint32_t)((unsigned)byteCode[3]|(unsigned)byteCode[4]*256u)*65536lu;
		delta=5;
		break;
		case 10:
		IS.arg.BBD.a_0=(uint16_t)byteCode[1]&15u;
		IS.arg.BBD.a_1=(uint16_t)byteCode[1]/16u;
		IS.arg.BBD.a_2=
		(uint32_t)((unsigned)byteCode[2]|(unsigned)byteCode[3]*256u)|
		(uint32_t)((unsigned)byteCode[4]|(unsigned)byteCode[5]*256u)*65536lu;
		delta=6;
		break;
		case 11:
		IS.arg.BWD.a_0=byteCode[1];
		IS.arg.BWD.a_1=(unsigned)byteCode[2]|(unsigned)byteCode[3]*256u;
		IS.arg.BWD.a_2=
		(uint32_t)((unsigned)byteCode[4]|(unsigned)byteCode[5]*256u)|
		(uint32_t)((unsigned)byteCode[6]|(unsigned)byteCode[7]*256u)*65536lu;
		delta=8;
		break;
		case 12:
		IS.arg.B4.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B4.a_1=(unsigned)byteCode[1]/16u;
		IS.arg.B4.a_2=(unsigned)byteCode[2]&15u;
		IS.arg.B4.a_3=(unsigned)byteCode[2]/16u;
		delta=3;
		break;
		case 13:
		IS.arg.B5.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B5.a_1=(unsigned)byteCode[1]/16u;
		IS.arg.B5.a_2=(unsigned)byteCode[2]&15u;
		IS.arg.B5.a_3=(unsigned)byteCode[2]/16u;
		IS.arg.B5.a_4=(unsigned)byteCode[3]&15u;
		delta=4;
		break;
		case 14:
		IS.arg.B6.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B6.a_1=(unsigned)byteCode[1]/16u;
		IS.arg.B6.a_2=(unsigned)byteCode[2]&15u;
		IS.arg.B6.a_3=(unsigned)byteCode[2]/16u;
		IS.arg.B6.a_4=(unsigned)byteCode[3]&15u;
		IS.arg.B6.a_5=(unsigned)byteCode[3]/16u;
		delta=4;
		break;
		case 15:
		IS.arg.B8.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B8.a_1=(unsigned)byteCode[1]/16u;
		IS.arg.B8.a_2=(unsigned)byteCode[2]&15u;
		IS.arg.B8.a_3=(unsigned)byteCode[2]/16u;
		IS.arg.B8.a_4=(unsigned)byteCode[3]&15u;
		IS.arg.B8.a_5=(unsigned)byteCode[3]/16u;
		IS.arg.B8.a_6=(unsigned)byteCode[4]&15u;
		IS.arg.B8.a_7=(unsigned)byteCode[4]/16u;
		delta=5;
		break;
	}
	*IS_parent=IS;
	return delta;
}

#ifndef IGNORE_NONBACKEND

InstructionBuffer decompressInstructionBufferOnLoad(){
	InstructionBuffer ib;
	initInstructionBuffer(&ib);
	while (true){
		uint8_t byteCode[8];
		InstructionSingle IS;
		IS.id=(byteCode[0]=binaryFile_noEOF_fgetc());
		if (byteCode[0]==0) return ib;
		uint8_t icc = instructionContentCatagory(IS.id);
		static uint8_t icc_to_delta[] = {[0]=0,[1]=1,[2]=2,[3]=2,[4]=2,[5]=3,[6]=3,[7]=3,[8]=4,[9]=5,[10]=6,[11]=8,[12]=3,[13]=4,[14]=4,[15]=5};
		const uint8_t delta=icc_to_delta[icc];
		for (uint8_t deltaTemp=1;deltaTemp<delta;deltaTemp++){
			byteCode[deltaTemp]=binaryFile_noEOF_fgetc();
		}
		decompressInstruction(byteCode,&IS);
		addInstruction(&ib,IS);
	}
}


void printInstructionBufferWithMessageAndNumber(const InstructionBuffer*,const char*,const uint32_t);
void printSingleInstructionOptCode(const InstructionSingle);


// decompressInstructionBuffer() expects validity and the terminating zero
InstructionBuffer decompressInstructionBuffer(const uint8_t* byteCodeStart){
	InstructionBuffer ib;
	initInstructionBuffer(&ib);
	const uint8_t* byteCode=byteCodeStart;
	uint32_t i=0;
	while (byteCode[i]){
		InstructionSingle IS;
		i+=decompressInstruction(byteCode+i,&IS);
		addInstruction(&ib,IS);
	}
	return ib;
}

void ensureInstructionBufferSize(InstructionBuffer* ib,uint32_t size){
	if (size>=ib->numberOfSlotsAllocated){
		do {
			ib->numberOfSlotsAllocated*=2;
		} while (size>=ib->numberOfSlotsAllocated);
		ib->buffer=cosmic_realloc(ib->buffer,ib->numberOfSlotsAllocated*sizeof(InstructionSingle));
	}
}

// the first is modified, the second is not
void singleMergeIB(InstructionBuffer* ib0, const InstructionBuffer* ib1){
	ensureInstructionBufferSize(ib0,ib0->numberOfSlotsTaken+ib1->numberOfSlotsTaken);
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib1->buffer,ib1->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib1->numberOfSlotsTaken;
}

void dualMergeIB(InstructionBuffer* ib0,const InstructionBuffer* ib1,const InstructionBuffer* ib2){
	ensureInstructionBufferSize(ib0,ib0->numberOfSlotsTaken+ib1->numberOfSlotsTaken+ib2->numberOfSlotsTaken);
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib1->buffer,ib1->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib1->numberOfSlotsTaken;
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib2->buffer,ib2->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib2->numberOfSlotsTaken;
}

void tripleMergeIB(InstructionBuffer* ib0,const InstructionBuffer* ib1,const InstructionBuffer* ib2,const InstructionBuffer* ib3){
	ensureInstructionBufferSize(ib0,ib0->numberOfSlotsTaken+ib1->numberOfSlotsTaken+ib2->numberOfSlotsTaken+ib3->numberOfSlotsTaken);
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib1->buffer,ib1->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib1->numberOfSlotsTaken;
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib2->buffer,ib2->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib2->numberOfSlotsTaken;
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib3->buffer,ib3->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib3->numberOfSlotsTaken;
}

void quadMergeIB(InstructionBuffer* ib0,const InstructionBuffer* ib1,const InstructionBuffer* ib2,const InstructionBuffer* ib3,const InstructionBuffer* ib4){
	ensureInstructionBufferSize(ib0,ib0->numberOfSlotsTaken+ib1->numberOfSlotsTaken+ib2->numberOfSlotsTaken+ib3->numberOfSlotsTaken+ib4->numberOfSlotsTaken);
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib1->buffer,ib1->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib1->numberOfSlotsTaken;
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib2->buffer,ib2->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib2->numberOfSlotsTaken;
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib3->buffer,ib3->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib3->numberOfSlotsTaken;
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib4->buffer,ib4->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib4->numberOfSlotsTaken;
}


// returns the delta
// assumes that the space is avalible in byteCode
uint8_t compressInstruction(uint8_t* byteCode,const InstructionSingle IS){
	switch (instructionContentCatagory(byteCode[0]=IS.id)){
		case 0:
		return 0;
		case 1:
		return 1;
		case 2:
		case 3:
		byteCode[1]=IS.arg.B1.a_0;
		return 2;
		case 4:
		byteCode[1]=IS.arg.B2.a_0|(IS.arg.B2.a_1*16);
		return 2;
		case 5:
		byteCode[1]=IS.arg.B3.a_0|(IS.arg.B3.a_1*16);
		byteCode[2]=IS.arg.B3.a_2;
		return 3;
		case 6:
		byteCode[1]=IS.arg.B2.a_0;
		byteCode[2]=IS.arg.B2.a_1;
		return 3;
		case 7:
		byteCode[1]=IS.arg.W.a_0&255;
		byteCode[2]=((unsigned)IS.arg.W.a_0&(255U*256U))/256U;
		return 3;
		case 8:
		byteCode[1]=IS.arg.BW.a_0;
		byteCode[2]=IS.arg.BW.a_1&255;
		byteCode[3]=((unsigned)IS.arg.BW.a_1&(255U*256U))/256U;
		return 4;
		case 9:
		byteCode[1]=IS.arg.D.a_0&255;
		byteCode[2]=((unsigned)IS.arg.D.a_0&(255U*256U))/256U;
		byteCode[3]=*((uint16_t*)&IS.arg.D.a_0+1)&255U;
		byteCode[4]=(*((uint16_t*)&IS.arg.D.a_0+1)&(255U*256U))/256U;
		return 5;
		case 10:
		byteCode[1]=IS.arg.BBD.a_0|(IS.arg.BBD.a_1*16);
		byteCode[2]=(unsigned)IS.arg.BBD.a_2&255U;
		byteCode[3]=((unsigned)IS.arg.BBD.a_2&(255U*256U))/256U;
		byteCode[4]=*((uint16_t*)&IS.arg.BBD.a_2+1)&255U;
		byteCode[5]=(*((uint16_t*)&IS.arg.BBD.a_2+1)&(255U*256U))/256U;
		return 6;
		case 11:
		byteCode[1]=IS.arg.BWD.a_0;
		byteCode[2]=IS.arg.BWD.a_1&255;
		byteCode[3]=((unsigned)IS.arg.BWD.a_1&(255U*256U))/256U;
		byteCode[4]=IS.arg.BWD.a_2&255;
		byteCode[5]=((unsigned)IS.arg.BWD.a_2&(255U*256U))/256U;
		byteCode[6]=*((uint16_t*)&IS.arg.BWD.a_2+1)&255U;
		byteCode[7]=(*((uint16_t*)&IS.arg.BWD.a_2+1)&(255U*256U))/256U;
		return 8;
		case 12:
		byteCode[1]=IS.arg.B4.a_0|(IS.arg.B4.a_1*16);
		byteCode[2]=IS.arg.B4.a_2|(IS.arg.B4.a_3*16);
		return 3;
		case 13:
		byteCode[1]=IS.arg.B5.a_0|(IS.arg.B5.a_1*16);
		byteCode[2]=IS.arg.B5.a_2|(IS.arg.B5.a_3*16);
		byteCode[3]=IS.arg.B5.a_4;
		return 4;
		case 14:
		byteCode[1]=IS.arg.B6.a_0|(IS.arg.B6.a_1*16);
		byteCode[2]=IS.arg.B6.a_2|(IS.arg.B6.a_3*16);
		byteCode[3]=IS.arg.B6.a_4|(IS.arg.B6.a_5*16);
		return 4;
		case 15:
		byteCode[1]=IS.arg.B8.a_0|(IS.arg.B8.a_1*16);
		byteCode[2]=IS.arg.B8.a_2|(IS.arg.B8.a_3*16);
		byteCode[3]=IS.arg.B8.a_4|(IS.arg.B8.a_5*16);
		byteCode[4]=IS.arg.B8.a_6|(IS.arg.B8.a_7*16);
		return 5;
	}
	assert(false);
	exit(1);
}

uint8_t getStorageDeltaForInstruction(enum InstructionTypeID id){
	// if something changes, do not just change this, there are other places
	static const uint8_t deltas[]={
		[ 0]=0,[ 1]=1,[ 2]=2,[ 3]=2,[ 4]=2,[ 5]=3,[ 6]=3,[ 7]=3,[ 8]=4,[ 9]=5,[10]=6,[11]=8,[12]=3,[13]=4,[14]=4,[15]=5
	};
	return deltas[instructionContentCatagory(id)];
}

CompressedInstructionBuffer compressInstructionBuffer(const InstructionBuffer* ib){
	CompressedInstructionBuffer cib;
	cib.allocLen=1;
	uint32_t numberOfSlotsTaken=ib->numberOfSlotsTaken;
	for (uint32_t i=0;i<numberOfSlotsTaken;i++){
		cib.allocLen+=getStorageDeltaForInstruction(ib->buffer[i].id);
	}
	cib.byteCode=cosmic_malloc(cib.allocLen*sizeof(uint8_t));
	uint8_t* byteCode=cib.byteCode;
	for (uint32_t i=0;i<numberOfSlotsTaken;i++){
		byteCode+=compressInstruction(byteCode,ib->buffer[i]);
	}
	*byteCode=0;
	assert(cib.byteCode+(cib.allocLen-1)==byteCode);
	return cib;
}


struct InstructionBuffersOfFunctions{
	CompressedInstructionBuffer* slots;
	uint32_t numberOfSlotsAllocated;
	uint32_t numberOfSlotsTaken;
} globalInstructionBuffersOfFunctions;

// input is destroyed
void addEntryToInstructionBuffersOfFunctions(InstructionBuffer* ib){
	if (globalInstructionBuffersOfFunctions.numberOfSlotsTaken>=globalInstructionBuffersOfFunctions.numberOfSlotsAllocated){
		globalInstructionBuffersOfFunctions.numberOfSlotsAllocated+=100;
		globalInstructionBuffersOfFunctions.slots = cosmic_realloc(
			globalInstructionBuffersOfFunctions.slots,
			globalInstructionBuffersOfFunctions.numberOfSlotsAllocated*sizeof(InstructionBuffer));
	}
	CompressedInstructionBuffer cib=compressInstructionBuffer(ib);
	globalInstructionBuffersOfFunctions.slots[globalInstructionBuffersOfFunctions.numberOfSlotsTaken++]=cib;
	destroyInstructionBuffer(ib);
}

void applyLabelRenamesInAllCompressedInstructionBuffers(const uint32_t* fromArr,const uint32_t* toArr,const uint32_t arrLen){
	if (arrLen==0) return;
	for (uint32_t i0=0;i0<globalInstructionBuffersOfFunctions.numberOfSlotsTaken;i0++){
		uint8_t* byteCode=globalInstructionBuffersOfFunctions.slots[i0].byteCode;
		while (*byteCode!=0){
			bool didChange=false;
			enum InstructionTypeID id=*byteCode;
			InstructionSingle IS;
			uint8_t delta;
			if (id==I_LABL | id==I_SYCL | id==I_JTEN | id==I_FCST){
				delta=decompressInstruction(byteCode,&IS);
				for (uint32_t i1=0;i1<arrLen;i1++){
					if (IS.arg.D.a_0==fromArr[i1]){IS.arg.D.a_0=toArr[i1];didChange=true;break;}
				}
			} else if (id==I_JJMP){
				delta=decompressInstruction(byteCode,&IS);
				for (uint32_t i1=0;i1<arrLen;i1++){
					if (IS.arg.BBD.a_2==fromArr[i1]){IS.arg.BBD.a_2=toArr[i1];didChange=true;break;}
				}
			} else {
				delta=getStorageDeltaForInstruction(id);
			}
			if (didChange) compressInstruction(byteCode,IS);
			byteCode+=delta;
		}
	}
}

void applyLabelRenamesInInstructionBuffer(InstructionBuffer* ib,const uint32_t* fromArr,const uint32_t* toArr,const uint32_t arrLen){
	if (arrLen==0) return;
	uint32_t numberOfSlotsTaken=ib->numberOfSlotsTaken;
	InstructionSingle* buffer=ib->buffer;
	for (uint32_t i=0;i<numberOfSlotsTaken;i++){
		enum InstructionTypeID id=buffer[i].id;
		uint32_t lablVal;
		uint32_t* lablPtr;
		if (id==I_LABL | id==I_SYCL | id==I_JTEN | id==I_FCST){
			lablPtr=&buffer[i].arg.D.a_0;
			Search:
			lablVal=*lablPtr;
			for (uint32_t i1=0;i1<arrLen;i1++){
				if (lablVal==fromArr[i1]){*lablPtr=toArr[i1];break;}
			}
		} else if (id==I_JJMP){
			lablPtr=&buffer[i].arg.BBD.a_2;
			goto Search;
		}
	}
}

// label markoffs do not check LABL or FCST
void doLabelMarkoffInAllCompressedInstructionBuffers(uint32_t* labelMarkoff,const uint32_t arrLen){
	if (arrLen==0) return;
	for (uint32_t i0=0;i0<globalInstructionBuffersOfFunctions.numberOfSlotsTaken;i0++){
		uint8_t* byteCode=globalInstructionBuffersOfFunctions.slots[i0].byteCode;
		while (*byteCode!=0){
			enum InstructionTypeID id=*byteCode;
			InstructionSingle IS;
			uint32_t lablVal;
			uint8_t delta;
			if (id==I_SYCL | id==I_JTEN){
				delta=decompressInstruction(byteCode,&IS);
				lablVal=IS.arg.D.a_0;
				Search:
				for (uint32_t i1=0;i1<arrLen;i1++){
					if (lablVal==labelMarkoff[i1]){labelMarkoff[i1]=0;break;}
				}
			} else if (id==I_JJMP){
				delta=decompressInstruction(byteCode,&IS);
				lablVal=IS.arg.BBD.a_2;
				goto Search;
			} else {
				delta=getStorageDeltaForInstruction(id);
			}
			byteCode+=delta;
		}
	}
}

// label markoffs do not check LABL or FCST
void doLabelMarkoffInInstructionBuffer(const InstructionBuffer* ib,uint32_t* labelMarkoff,const uint32_t arrLen){
	if (arrLen==0) return;
	uint32_t numberOfSlotsTaken=ib->numberOfSlotsTaken;
	InstructionSingle* buffer=ib->buffer;
	for (uint32_t i=0;i<numberOfSlotsTaken;i++){
		enum InstructionTypeID id=buffer[i].id;
		uint32_t lablVal;
		if (id==I_SYCL | id==I_JTEN){
			lablVal=buffer[i].arg.D.a_0;
			Search:
			for (uint32_t i1=0;i1<arrLen;i1++){
				if (lablVal==labelMarkoff[i1]){labelMarkoff[i1]=0;break;}
			}
		} else if (id==I_JJMP){
			lablVal=buffer[i].arg.BBD.a_2;
			goto Search;
		}
	}
}




// these functions that follow are to avoid using InstructionSingle in expressionToInstructions

void add_ALCR(InstructionBuffer* ib, uint16_t size){
	InstructionSingle IS;
	IS.id=I_ALCR;
	IS.arg.BW.a_0=11;
	IS.arg.BW.a_1=size;
	addInstruction(ib,IS);
}

void addVoidPop(InstructionBuffer* ib){
	InstructionSingle IS;
	IS.id=I_POP1;
	IS.arg.B1.a_0=3;
	addInstruction(ib,IS);
}

void addQuadVoidPop(InstructionBuffer* ib){
	addVoidPop(ib);
	addVoidPop(ib);
	addVoidPop(ib);
	addVoidPop(ib);
}

void addPopArgPush1(InstructionBuffer* ib){
	InstructionSingle IS;
	IS.id=I_POP1;
	IS.arg.B1.a_0=3;
	addInstruction(ib,IS);
	IS.id=I_PUA1;
	IS.arg.B1.a_0=3;
	addInstruction(ib,IS);
}

void addPopArgPush2(InstructionBuffer* ib){
	InstructionSingle IS;
	IS.id=I_POP2;
	IS.arg.B2.a_0=3;
	IS.arg.B2.a_1=4;
	addInstruction(ib,IS);
	IS.id=I_PUA2;
	IS.arg.B2.a_0=4;
	IS.arg.B2.a_1=3;
	addInstruction(ib,IS);
}


/*
addStructArgPush() is if isLValue==true
otherwise, this should not be called and the argument should be treated as pushed as an argument. 
I don't think the optimizer will have a problem with that.
*/
void addStructArgPush(InstructionBuffer* ib, uint16_t size, bool isVolatile){
	InstructionSingle IS;
	IS.id=I_POP2;
	IS.arg.B2.a_0=3;
	IS.arg.B2.a_1=4;
	addInstruction(ib,IS);
	while (size){
		size-=2;
		IS.id=I_RL1_;
		IS.arg.BW.a_0=6;
		IS.arg.BW.a_1=size;
		addInstruction(ib,IS);
		IS.id=I_LAD1;
		IS.arg.B5.a_0=7;
		IS.arg.B5.a_1=8;
		IS.arg.B5.a_2=3;
		IS.arg.B5.a_3=4;
		IS.arg.B5.a_4=6;
		addInstruction(ib,IS);
		if (isVolatile) IS.id=I_MRWV;
		else IS.id=I_MRWN;
		IS.arg.B3.a_0=5;
		IS.arg.B3.a_1=7;
		IS.arg.B3.a_2=8;
		addInstruction(ib,IS);
		IS.id=I_PUA1;
		IS.arg.B1.a_0=5;
		addInstruction(ib,IS);
	}
}



// pops an rvalue struct from the stack. should have address pushed after struct
// isVolatile obviously refers to the write operation.
// when it is finished, the original address is pushed back to the stack
void addStructStackAssign(InstructionBuffer* ib, uint16_t size, bool isVolatile){
	uint16_t initSize=size;
	InstructionSingle IS;
	IS.id=I_POP2;
	IS.arg.B2.a_0=3;
	IS.arg.B2.a_1=4;
	addInstruction(ib,IS);
	while (size){
		IS.id=I_POP1;
		IS.arg.B1.a_0=5;
		addInstruction(ib,IS);
		IS.id=I_RL1_;
		IS.arg.BW.a_0=6;
		IS.arg.BW.a_1=initSize-size;
		size-=2;
		addInstruction(ib,IS);
		IS.id=I_LAD1;
		IS.arg.B5.a_0=7;
		IS.arg.B5.a_1=8;
		IS.arg.B5.a_2=3;
		IS.arg.B5.a_3=4;
		IS.arg.B5.a_4=6;
		addInstruction(ib,IS);
		if (isVolatile) IS.id=I_MWWV;
		else IS.id=I_MWWN;
		IS.arg.B3.a_0=5;
		IS.arg.B3.a_1=7;
		IS.arg.B3.a_2=8;
		addInstruction(ib,IS);
	}
	IS.id=I_PU2_;
	IS.arg.B2.a_0=4;
	IS.arg.B2.a_1=3;
	addInstruction(ib,IS);
}


// for after an initializer finishes
void convertSTPI_STPA(InstructionBuffer* ib, uint16_t offsetToAdd){
	for (uint32_t i=0;i<ib->numberOfSlotsTaken;i++){
		if (ib->buffer[i].id==I_STPI){
			ib->buffer[i].id=I_STPA;
			uint16_t* vp=&ib->buffer[i].arg.BW.a_1;
			*vp=offsetToAdd-*vp;
		}
	}
}

#endif // #ifndef IGNORE_NONBACKEND
