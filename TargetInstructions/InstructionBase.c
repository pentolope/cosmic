
typedef struct InstructionSingle{
	enum InstructionTypeID {
		I_ERR_ = 0, // I_ERR_ is not an instruction, if it is encountered, the compiler should terminate execution
		I_NOP_,
		I_PU1_,
		I_PU2_,
		I_PUA1,
		I_PUA2,
		I_POP1,
		I_POP2,
		I_BL1_,
		I_RL1_,
		I_RL2_,
		I_CALL,
		I_RET_,
		I_STPA,
		I_STPS,

		I_STWN,
		I_STRN,
		I_STWV,
		I_STRV,

		I_ALOC,
		I_ALCR,
		I_STOF,
		
		I_AJMP,
		I_CJMP,
		
		I_JJMP,
		I_JTEN,
		I_JEND,

		I_MOV_,

		I_AND_,
		I_OR__,
		I_XOR_,
		I_SSUB,

		I_ADDN,
		I_ADDC,
		I_SUBN,
		I_SUBC,

		I_MULS,
		I_MULL,
		I_DIVM,

		I_SHFT,
		I_BSWP,

		I_MWWN,
		I_MRWN,
		I_MWWV,
		I_MRWV,
		I_MWBN,
		I_MRBN,
		I_MWBV,
		I_MRBV,

		I_LABL,
		
		I_PHIS,
		I_PHIE,
		
		I_D32U,
		I_R32U,
		I_D32S,
		I_R32S,
		
		I_FCST,
		I_FCEN,
		
		I_SYRB,
		I_SYRW,
		I_SYRD,
		I_SYRE,

		I_SYCB,
		I_SYCW,
		I_SYCD,
		I_SYCL,

		I_SYC0,
		I_SYC1,
		I_SYC2,
		I_SYC3,
		I_SYC4,
		I_SYC5,
		I_SYC6,
		I_SYC7,
		I_SYC8,
		I_SYC9,

		I_SYCZ,
		I_SYCS,
		I_SYCT,
		
		// the following should not be encontered by the instruction optimizer
		I_NSPB,
		I_NSPW,
		I_ZNXB,
		I_ZNXW,

		I_BYTE,
		I_WORD,
		I_DWRD,

		I_SYDB,
		I_SYDW,
		I_SYDD,
		I_SYDE,
		
		I_DEPL, // I_DEPL is used for when a depth limit is reached for peephole optimization templates, it is not an instruction
		I_PEPH, // used in peephole optimization templates for poping or pushing a value
		
		I_STPI, // for placing initializer offsets. Is converted to I_STPA after the variable's local offset is calculated.
		
		I_INSR // this is the insert placeholder for core entries, it is not an instruction. It uses the 'B' struct in the 'arg' union
	} id;
	union {
		struct {
			uint8_t a_0;
		} B;
		struct {
			uint8_t a_0;
			uint8_t a_1;
		} BB;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint8_t a_2;
		} BBB;
		struct {
			uint8_t a_0;
			uint16_t a_1;
		} BW;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint16_t a_2;
		} BBW;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint32_t a_2;
		} BBD;
		struct {
			uint8_t a_0;
			uint16_t a_1;
			uint32_t a_2;
		} BWD;
		struct {
			uint16_t a_0;
		} W;
		struct {
			uint32_t a_0;
			bool mark; // [for use on LABL only] may be used in the optimizer to avoid infinite loops (as of writing this it is unused)
		} D;
	} arg;
} InstructionSingle;


/*
I_PHIS - phi start
I_PHIE - phi end

phi nodes are used to access register values across jumps and labels.
the I_PHIS 'instruction', according to the optimizer, contains one register of  input that is not renamable and not reorderable
the I_PHIE 'instruction', according to the optimizer, contains one register of output that is not renamable and not reorderable
*/



typedef struct CompressedInstructionBuffer{
	uint8_t* byteCode;
} CompressedInstructionBuffer;


// InstructionBuffer has initializers (that are generated by the python script), so don't change it around
typedef struct InstructionBuffer{
	InstructionSingle* buffer;
	uint32_t numberOfSlotsAllocated;
	uint32_t numberOfSlotsTaken;
} InstructionBuffer;


// for debug
void printInstructionBufferWithMessageAndNumber(const InstructionBuffer*,const char*,const uint32_t);

struct InstructionBuffersOfFunctions{
	CompressedInstructionBuffer* slots;
	uint32_t numberOfSlotsAllocated;
	uint32_t numberOfSlotsTaken;
} globalInstructionBuffersOfFunctions;

const InstructionBuffer resetInstructionBuffer={0};
#define INIT_INSTRUCTION_BUFFER_SIZE 1024


void initInstructionBuffer(InstructionBuffer* ib){
	*ib=resetInstructionBuffer;
	ib->numberOfSlotsAllocated = INIT_INSTRUCTION_BUFFER_SIZE;
	ib->buffer = cosmic_malloc(ib->numberOfSlotsAllocated*sizeof(InstructionSingle));
}

void destroyInstructionBuffer(InstructionBuffer* ib){
	if (ib->buffer!=NULL){
		cosmic_free(ib->buffer);
		ib->buffer = NULL;
		ib->numberOfSlotsTaken = 0;
		ib->numberOfSlotsAllocated = 0;
	}
}

void addInstruction(InstructionBuffer* ib, const InstructionSingle instructionSingle){
	if (ib->numberOfSlotsTaken>=ib->numberOfSlotsAllocated){
		assert(ib->numberOfSlotsAllocated!=0); // Cannot add instruction to destroyed instruction buffer
		ib->numberOfSlotsAllocated*=2;
		ib->buffer = cosmic_realloc(ib->buffer,ib->numberOfSlotsAllocated*sizeof(InstructionSingle));
	}
	ib->buffer[ib->numberOfSlotsTaken++]=instructionSingle;
}

// the first is modified, the second is not
void singleMergeIB(InstructionBuffer* ib1, const InstructionBuffer* ib2){
	uint32_t numberOfSlotsTakenOn2=ib2->numberOfSlotsTaken;
	for (uint32_t i=0;i<numberOfSlotsTakenOn2;i++){
		addInstruction(ib1,ib2->buffer[i]);
	}
}

void quadMergeIB(InstructionBuffer* ib0,const InstructionBuffer* ib1,const InstructionBuffer* ib2,const InstructionBuffer* ib3,const InstructionBuffer* ib4){
	singleMergeIB(ib0,ib1);
	singleMergeIB(ib0,ib2);
	singleMergeIB(ib0,ib3);
	singleMergeIB(ib0,ib4);
}

void tripleMergeIB(InstructionBuffer* ib0,const InstructionBuffer* ib1,const InstructionBuffer* ib2,const InstructionBuffer* ib3){
	singleMergeIB(ib0,ib1);
	singleMergeIB(ib0,ib2);
	singleMergeIB(ib0,ib3);
}

void dualMergeIB(InstructionBuffer* ib0,const InstructionBuffer* ib1,const InstructionBuffer* ib2){
	singleMergeIB(ib0,ib1);
	singleMergeIB(ib0,ib2);
}

uint8_t instructionContentCatagory(enum InstructionTypeID id){
	switch (id){
		case I_NOP_:
		case I_FCEN:
		case I_RET_:
		case I_ALOC:
		case I_D32U:
		case I_R32U:
		case I_D32S:
		case I_R32S:
		case I_JEND:
		case I_SYRE:
		case I_SYDB:
		case I_SYDW:
		case I_SYDD:
		case I_SYDE:
		case I_SYC0:
		case I_SYC1:
		case I_SYC2:
		case I_SYC3:
		case I_SYC4:
		case I_SYC5:
		case I_SYC6:
		case I_SYC7:
		case I_SYC8:
		case I_SYC9:
		case I_SYCZ:
		case I_SYCS:
		case I_SYCT:
		return 0;
		case I_PU1_:
		case I_PUA1:
		case I_POP1:
		case I_SYRB:
		case I_SYRW:
		case I_PHIS:
		case I_PHIE:
		return 1;
		case I_BYTE:
		case I_SYCB:
		return 2;
		case I_PU2_:
		case I_PUA2:
		case I_POP2:
		case I_CALL:
		case I_AJMP:
		case I_MULS:
		case I_MULL:
		case I_DIVM:
		case I_SHFT:
		case I_BSWP:
		case I_MWBN:
		case I_MRBN:
		case I_MWBV:
		case I_MRBV:
		case I_MOV_:
		case I_SYRD:
		return 3;
		case I_AND_:
		case I_OR__:
		case I_XOR_:
		case I_SSUB:
		case I_ADDN:
		case I_ADDC:
		case I_SUBN:
		case I_SUBC:
		case I_MWWN:
		case I_MRWN:
		case I_MWWV:
		case I_MRWV:
		case I_CJMP:
		return 4;
		case I_BL1_:
		case I_STWN:
		case I_STRN:
		case I_STWV:
		case I_STRV:
		return 5;
		case I_WORD:
		case I_SYCW:
		return 6;
		case I_RL1_:
		case I_ALCR:
		case I_STPA:
		case I_STPS:
		return 7;
		case I_STOF:
		return 8;
		case I_RL2_:
		case I_JJMP:
		return 9;
		case I_LABL:
		case I_DWRD:
		case I_SYCD:
		case I_JTEN:
		case I_SYCL:
		return 10;
		case I_FCST:
		return 11;
		default:;
	}
	printf("Invalid operator ID\n");
	exit(1);
}

CompressedInstructionBuffer compressInstructionBuffer(const InstructionBuffer* ib){
	CompressedInstructionBuffer cib;
	uint32_t length=1;
	for (uint32_t i=0;i<ib->numberOfSlotsTaken;i++){
		uint16_t delta=0;
		switch (instructionContentCatagory(ib->buffer[i].id)){
			case 0:
			delta=1;
			break;
			case 1:
			case 2:
			case 3:
			delta=2;
			break;
			case 4:
			case 5:
			case 6:
			delta=3;
			break;
			case 7:
			case 8:
			delta=4;
			break;
			case 9:
			case 10:
			delta=6;
			break;
			case 11:
			delta=8;
			break;
		}
		length+=delta;
	}
	cib.byteCode=cosmic_calloc(length+1,sizeof(uint8_t));
	uint8_t* byteCode=cib.byteCode;
	uint32_t ic=0;
	for (uint32_t i=0;i<ib->numberOfSlotsTaken;i++){
		InstructionSingle IS=ib->buffer[i];
		switch (instructionContentCatagory(byteCode[ic++]=IS.id)){
			case 0:
			break;
			case 1:
			case 2:
			byteCode[ic++]=IS.arg.B.a_0;
			break;
			case 3:
			byteCode[ic++]=IS.arg.BB.a_0|(IS.arg.BB.a_1*16);
			break;
			case 4:
			byteCode[ic++]=IS.arg.BBB.a_0|(IS.arg.BBB.a_1*16);
			byteCode[ic++]=IS.arg.BBB.a_2;
			break;
			case 5:
			byteCode[ic++]=IS.arg.BB.a_0;
			byteCode[ic++]=IS.arg.BB.a_1;
			break;
			case 6:
			byteCode[ic++]=IS.arg.W.a_0&255U;
			byteCode[ic++]=(IS.arg.W.a_0&(255U*256U))/256U;
			break;
			case 7:
			byteCode[ic++]=IS.arg.BW.a_0;
			byteCode[ic++]=IS.arg.BW.a_1&255U;
			byteCode[ic++]=(IS.arg.BW.a_1&(255U*256U))/256U;
			break;
			case 8:
			byteCode[ic++]=IS.arg.BBW.a_0|(IS.arg.BBW.a_1*16);
			byteCode[ic++]=IS.arg.BBW.a_2&255U;
			byteCode[ic++]=(IS.arg.BBW.a_2&(255U*256U))/256U;
			break;
			case 9:
			byteCode[ic++]=(uint16_t)IS.arg.D.a_0&255U;
			byteCode[ic++]=((uint16_t)IS.arg.D.a_0&(255U*256U))/256U;
			byteCode[ic++]=*((uint16_t*)&IS.arg.D.a_0+1)&255U;
			byteCode[ic++]=(*((uint16_t*)&IS.arg.D.a_0+1)&(255U*256U))/256U;
			break;
			case 10:
			byteCode[ic++]=IS.arg.BBD.a_0|(IS.arg.BBD.a_1*16);
			byteCode[ic++]=(uint16_t)IS.arg.BBD.a_2&255U;
			byteCode[ic++]=((uint16_t)IS.arg.BBD.a_2&(255U*256U))/256U;
			byteCode[ic++]=*((uint16_t*)&IS.arg.BBD.a_2+1)&255U;
			byteCode[ic++]=(*((uint16_t*)&IS.arg.BBD.a_2+1)&(255U*256U))/256U;
			break;
			case 11:
			byteCode[ic++]=IS.arg.BWD.a_0;
			byteCode[ic++]=IS.arg.BWD.a_1&255U;
			byteCode[ic++]=(IS.arg.BWD.a_1&(255U*256U))/256U;
			byteCode[ic++]=(uint16_t)IS.arg.BWD.a_2&255U;
			byteCode[ic++]=((uint16_t)IS.arg.BWD.a_2&(255U*256U))/256U;
			byteCode[ic++]=*((uint16_t*)&IS.arg.BWD.a_2+1)&255U;
			byteCode[ic++]=(*((uint16_t*)&IS.arg.BWD.a_2+1)&(255U*256U))/256U;
			break;
		}
	}
	return cib;
}


InstructionBuffer decompressInstructionBuffer(const CompressedInstructionBuffer cib){
	InstructionBuffer ib;
	initInstructionBuffer(&ib);
	uint8_t* byteCode=cib.byteCode;
	for (uint32_t i=0;byteCode[i];){
		uint16_t delta=0;
		InstructionSingle IS;
		enum InstructionTypeID id=IS.id=byteCode[i];
		switch(instructionContentCatagory(IS.id=byteCode[i])){
			case 0:
			delta=1;
			break;
			case 1:
			case 2:
			IS.arg.B.a_0=(uint16_t)byteCode[i+1]&15U;
			delta=2;
			break;
			case 3:
			IS.arg.BB.a_0=(uint16_t)byteCode[i+1]&15U;
			IS.arg.BB.a_1=(uint16_t)byteCode[i+1]/16U;
			delta=2;
			break;
			case 4:
			IS.arg.BBB.a_0=(uint16_t)byteCode[i+1]&15U;
			IS.arg.BBB.a_1=(uint16_t)byteCode[i+1]/16U;
			IS.arg.BBB.a_2=(uint16_t)byteCode[i+2]&15U;
			delta=3;
			break;
			case 5:
			IS.arg.BB.a_0=(uint16_t)byteCode[i+1]&15U;
			IS.arg.BB.a_1=(uint16_t)byteCode[i+2];
			delta=3;
			break;
			case 6:
			IS.arg.W.a_0=(uint16_t)byteCode[i+1]|(uint16_t)byteCode[i+2]*256U;
			delta=3;
			break;
			case 7:
			IS.arg.BW.a_0=(uint16_t)byteCode[i+1]&15U;
			IS.arg.BW.a_1=(uint16_t)byteCode[i+2]|(uint16_t)byteCode[i+3]*256U;
			delta=4;
			break;
			case 8:
			IS.arg.BBW.a_0=(uint16_t)byteCode[i+1]&15U;
			IS.arg.BBW.a_1=(uint16_t)byteCode[i+1]/16U;
			IS.arg.BBW.a_2=(uint16_t)byteCode[i+2]|(uint16_t)byteCode[i+3]*256U;
			delta=4;
			break;
			case 9:
			IS.arg.D.a_0=
			(uint32_t)((uint16_t)byteCode[i+1]|(uint16_t)byteCode[i+2]*256U)|
			(uint32_t)((uint16_t)byteCode[i+3]|(uint16_t)byteCode[i+4]*256U)*65536LU;
			delta=5;
			break;
			case 10:
			IS.arg.BBD.a_0=(uint16_t)byteCode[i+1]&15U;
			IS.arg.BBD.a_1=(uint16_t)byteCode[i+1]/16U;
			IS.arg.BBD.a_2=
			(uint32_t)((uint16_t)byteCode[i+2]|(uint16_t)byteCode[i+3]*256U)|
			(uint32_t)((uint16_t)byteCode[i+4]|(uint16_t)byteCode[i+5]*256U)*65536LU;
			delta=6;
			break;
			case 11:
			IS.arg.BWD.a_0=(uint16_t)byteCode[i+1]&15U;
			IS.arg.BWD.a_1=(uint16_t)byteCode[i+2]|(uint16_t)byteCode[i+3]*256U;
			IS.arg.BWD.a_2=
			(uint32_t)((uint16_t)byteCode[i+4]|(uint16_t)byteCode[i+5]*256U)|
			(uint32_t)((uint16_t)byteCode[i+6]|(uint16_t)byteCode[i+7]*256U)*65536LU;
			delta=8;
			break;
		}
		i+=delta;
		addInstruction(&ib,IS);
	}
	return ib;
}


// input is destroyed
void addEntryToInstructionBuffersOfFunctions(InstructionBuffer* ib){
	if (globalInstructionBuffersOfFunctions.numberOfSlotsTaken>=globalInstructionBuffersOfFunctions.numberOfSlotsAllocated){
		globalInstructionBuffersOfFunctions.numberOfSlotsAllocated+=100;
		globalInstructionBuffersOfFunctions.slots = cosmic_realloc(
			globalInstructionBuffersOfFunctions.slots,
			globalInstructionBuffersOfFunctions.numberOfSlotsAllocated*sizeof(InstructionBuffer));
	}
	CompressedInstructionBuffer cib=compressInstructionBuffer(ib);
	globalInstructionBuffersOfFunctions.slots[globalInstructionBuffersOfFunctions.numberOfSlotsTaken++]=cib;
	destroyInstructionBuffer(ib);
}


// these functions that follow are to avoid using InstructionSingle in expressionToInstructions


void addVoidPop(InstructionBuffer* ib){
	InstructionSingle IS;
	IS.id=I_POP1;
	IS.arg.B.a_0=3;
	addInstruction(ib,IS);
}

void addQuadVoidPop(InstructionBuffer* ib){
	addVoidPop(ib);
	addVoidPop(ib);
	addVoidPop(ib);
	addVoidPop(ib);
}

void addPopArgPush1(InstructionBuffer* ib){
	InstructionSingle IS;
	IS.id=I_POP1;
	IS.arg.B.a_0=3;
	addInstruction(ib,IS);
	IS.id=I_PUA1;
	IS.arg.B.a_0=3;
	addInstruction(ib,IS);
}

void addPopArgPush2(InstructionBuffer* ib){
	InstructionSingle IS;
	IS.id=I_POP2;
	IS.arg.BB.a_0=3;
	IS.arg.BB.a_1=4;
	addInstruction(ib,IS);
	IS.id=I_PUA2;
	IS.arg.BB.a_0=4;
	IS.arg.BB.a_1=3;
	addInstruction(ib,IS);
}


/*
addStructArgPush() is for if isActuallyAddressBecauseUnionOrStruct==true

if isActuallyAddressBecauseUnionOrStruct==false, then this should not be called
  and the argument should be treated as pushed as an argument. I don't think the optimizer will have a problem with that.
*/
void addStructArgPush(InstructionBuffer* ib, uint16_t size, bool isVolatile){
	InstructionSingle IS;
	IS.id=I_POP2;
	IS.arg.BB.a_0=3;
	IS.arg.BB.a_1=4;
	addInstruction(ib,IS);
	IS.id=I_BL1_;
	IS.arg.BB.a_0=6;
	IS.arg.BB.a_1=2;
	addInstruction(ib,IS);
	while (size){
		if (isVolatile) IS.id=I_MRWV;
		else IS.id=I_MRWN;
		IS.arg.BBB.a_0=5;
		IS.arg.BBB.a_1=3;
		IS.arg.BBB.a_2=4;
		addInstruction(ib,IS);
		IS.id=I_ADDC;
		IS.arg.BBB.a_0=3;
		IS.arg.BBB.a_1=3;
		IS.arg.BBB.a_2=6;
		addInstruction(ib,IS);
		IS.id=I_ADDN;
		IS.arg.BBB.a_0=4;
		IS.arg.BBB.a_1=4;
		IS.arg.BBB.a_2=15;
		addInstruction(ib,IS);
		IS.id=I_PUA1;
		IS.arg.B.a_0=5;
		addInstruction(ib,IS);
		size-=2;
	}
}


// pops an rvalue struct from the stack. should have address pushed after struct
// isVolatile obviously refers to the write operation.
// when it is finished, the original address is pushed back to the stack
void addStructStackAssign(InstructionBuffer* ib, uint16_t size, bool isVolatile){
	InstructionSingle IS;
	IS.id=I_POP2;
	IS.arg.BB.a_0=3;
	IS.arg.BB.a_1=4;
	addInstruction(ib,IS);
	while (size){
		size-=2;
		IS.id=I_POP1;
		IS.arg.B.a_0=5;
		addInstruction(ib,IS);
		IS.id=I_RL1_;
		IS.arg.BW.a_0=6;
		IS.arg.BW.a_1=size;
		addInstruction(ib,IS);
		IS.id=I_ADDC;
		IS.arg.BBB.a_0=7;
		IS.arg.BBB.a_1=3;
		IS.arg.BBB.a_2=6;
		addInstruction(ib,IS);
		IS.id=I_ADDN;
		IS.arg.BBB.a_0=8;
		IS.arg.BBB.a_1=4;
		IS.arg.BBB.a_2=15;
		addInstruction(ib,IS);
		if (isVolatile) IS.id=I_MWWV;
		else IS.id=I_MWWN;
		IS.arg.BBB.a_0=5;
		IS.arg.BBB.a_1=7;
		IS.arg.BBB.a_2=8;
		addInstruction(ib,IS);
	}
	IS.id=I_PU2_;
	IS.arg.BB.a_0=4;
	IS.arg.BB.a_1=3;
	addInstruction(ib,IS);
}


// for after an initializer finishes
void convertSTPI_STPA(InstructionBuffer* ib, uint16_t offsetToAdd){
	for (uint32_t i=0;i<ib->numberOfSlotsTaken;i++){
		if (ib->buffer[i].id==I_STPI){
			ib->buffer[i].id=I_STPA;
			ib->buffer[i].arg.BBW.a_2+=offsetToAdd;
		}
	}
}










