

typedef struct InstructionSingle{
	enum InstructionTypeID {
		I_ERR_ = 0, // I_ERR_ is not an instruction, if it is encountered, the compiler should terminate execution
		I_NOP_,
		I_PU1_,
		I_PU2_,
		I_PUA1,
		I_PUA2,
		I_POP1,
		I_POP2,
		I_BL1_,
		I_RL1_,
		I_RL2_,
		I_CALL,
		I_RET_,
		I_STPA,
		I_STPS,
		I_STWN,
		I_STRN,
		I_STWV,
		I_STRV,
		I_ALOC,
		I_ALCR,
		I_STOF,
		I_AJMP,
		I_CJMP,
		I_JJMP,
		I_JTEN,
		I_JEND,
		I_MOV_,
		I_AND_,
		I_OR__,
		I_XOR_,
		I_SSUB,
		I_ADDN,
		I_SUBN,
		I_SUBC,
		I_MULS,
		I_MULL,
		I_DIVM,
		I_SHFT,
		I_BSWP,
		I_MWWN,
		I_MRWN,
		I_MWWV,
		I_MRWV,
		I_MWBN,
		I_MRBN,
		I_MWBV,
		I_MRBV,
		I_LABL,
		I_PHIS,
		I_PHIE,
		I_FCST,
		I_FCEN,
		I_D32U,
		I_R32U,
		I_D32S,
		I_R32S,
		I_D64U,
		I_R64U,
		I_D64S,
		I_R64S,
		I_LAD0,
		I_LAD1,
		I_LAD2,
		I_LAD3,
		I_LAD4,
		I_LAD5,
		I_LSU0,
		I_LSU3,
		I_LSU4,
		I_LSU5,
		I_LMU3,
		I_LMU4,
		I_LMU5,
		I_LDI4,
		I_LDI5,
		I_LLS6,
		I_LLS7,
		I_LRS6,
		I_LRS7,
		I_SYRB,
		I_SYRW,
		I_SYRD,
		I_SYRQ,
		I_SYRE,
		
		I_SYCB,
		I_SYCW,
		I_SYCD,
		I_SYCL,
		I_SYW0,
		I_SYW1,
		I_SYW2,
		I_SYW3,
		I_SYW4,
		I_SYW5,
		I_SYW6,
		I_SYW7,
		I_SYW8,
		I_SYW9,
		I_SBLW,
		I_SBRW,
		I_SYD0,
		I_SYD1,
		I_SYD2,
		I_SYD3,
		I_SYD4,
		I_SYD5,
		I_SYD6,
		I_SYD7,
		I_SYD8,
		I_SYD9,
		I_SBLD,
		I_SBRD,
		I_SYQ0,
		I_SYQ1,
		I_SYQ2,
		I_SYQ3,
		I_SYQ4,
		I_SYQ5,
		I_SYQ6,
		I_SYQ7,
		I_SYQ8,
		I_SYQ9,
		I_SBLQ,
		I_SBRQ,
		I_SCBW,
		I_SCWD,
		I_SCZD,
		I_SCDQ,
		I_SCZQ,
		I_SCQD,
		I_SCDW,
		I_SCWB,
		I_SCDB,
		I_SCQB,
		
		// the following should not be encontered by the instruction optimizer
		
		I_NSNB,
		I_ZNXB,
		I_BYTE,
		I_WORD,
		I_DWRD,
		I_SYDB,
		I_SYDW,
		I_SYDD,
		I_SYDQ,
		I_SYDE,
		
		I_DEPL, // I_DEPL is used for when a depth limit is reached for peephole optimization templates, it is not an instruction
		I_PEPH, // used in peephole optimization templates for poping or pushing a value
		
		I_STPI, // for placing initializer offsets. Is converted to I_STPA after the variable's local offset is calculated.
		
		I_LOFF, // used temporarily by listed initializers to indicate an offset of the data that comes next
		
		I_INSR // this is the insert placeholder for core entries, it is not an instruction. It uses the 'B1' struct in the 'arg' union
	} id;
	union {
		struct {
			uint8_t a_0;
		} B1;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			
			bool mem_flag_upper_byte_unused; // [for stack memory access instructions only] used to flag stack memory word accesses as having the upper or lower byte in memory being unused
			bool mem_flag_lower_byte_unused;
		} B2;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint8_t a_2;
			
			bool mem_flag_upper_byte_unused; // [for non-stack memory access instructions only] used to flag non-stack memory word accesses as having the upper or lower byte in memory being unused
			bool mem_flag_lower_byte_unused;
		} B3;
		struct {
			uint16_t a_1;
			uint8_t a_0;
		} BW;
		struct {
			uint32_t a_2;
			uint8_t a_0;
			uint8_t a_1;
		} BBD;
		struct {
			uint32_t a_2;
			uint16_t a_1;
			uint8_t a_0;
		} BWD;
		struct {
			uint16_t a_0;
		} W;
		struct {
			uint32_t a_0;
			
			bool mark; // [for use on LABL only] used in the optimizer to avoid infinite loops
		} D;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint8_t a_2;
			uint8_t a_3;
		} B4;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint8_t a_2;
			uint8_t a_3;
			uint8_t a_4;
		} B5;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint8_t a_2;
			uint8_t a_3;
			uint8_t a_4;
			uint8_t a_5;
		} B6;
		struct {
			uint8_t a_0;
			uint8_t a_1;
			uint8_t a_2;
			uint8_t a_3;
			uint8_t a_4;
			uint8_t a_5;
			uint8_t a_6;
			uint8_t a_7;
		} B8;
	} arg;
} InstructionSingle;

typedef struct CompressedInstructionBuffer{
	uint8_t* byteCode;
	uint32_t allocLen;
} CompressedInstructionBuffer;


// InstructionBuffer has initializers (that are generated by the python script), so don't change it around
typedef struct InstructionBuffer{
	InstructionSingle* buffer;
	uint32_t numberOfSlotsAllocated;
	uint32_t numberOfSlotsTaken;
} InstructionBuffer;


// The following instructions cannot be calculated using this lookup table: I_ALCR,I_STOF,I_ZNXB
static uint8_t instruction_id_to_backend_size[]={
	[I_SYDB]=1,
	[I_BYTE]=1,
	[I_RET_]=2,
	[I_PU1_]=2,
	[I_PU2_]=2,
	[I_PUA1]=2,
	[I_PUA2]=2,
	[I_POP1]=2,
	[I_POP2]=2,
	[I_CALL]=2,
	[I_MULS]=2,
	[I_MULL]=2,
	[I_DIVM]=2,
	[I_SHFT]=2,
	[I_BSWP]=2,
	[I_MOV_]=2,
	[I_AND_]=2,
	[I_OR__]=2,
	[I_XOR_]=2,
	[I_ADDN]=2,
	[I_SSUB]=2,
	[I_SUBN]=2,
	[I_SUBC]=2,
	[I_MWBN]=2,
	[I_MRBN]=2,
	[I_MWBV]=2,
	[I_MRBV]=2,
	[I_MWWN]=2,
	[I_MRWN]=2,
	[I_MWWV]=2,
	[I_MRWV]=2,
	[I_STWN]=2,
	[I_STRN]=2,
	[I_STWV]=2,
	[I_STRV]=2,
	[I_CJMP]=2,
	[I_JJMP]=2,
	[I_AJMP]=2,
	[I_SYRB]=2,
	[I_BL1_]=2,
	[I_SYDW]=2,
	[I_WORD]=2,
	[I_SYRW]=4,
	[I_RL1_]=4,
	[I_STPS]=4,
	[I_JTEN]=4,
	[I_SYDD]=4,
	[I_DWRD]=4,
	[I_STPA]=6,
	[I_ALOC]=6,
	[I_LAD0]=6,
	[I_LAD1]=6,
	[I_LAD2]=6,
	[I_LSU0]=6,
	[I_RL2_]=8,
	[I_SYRD]=8,
	[I_SYDQ]=8,
	[I_LAD3]=10,
	[I_D32U]=14,
	[I_R32U]=14,
	[I_D32S]=14,
	[I_R32S]=14,
	[I_D64U]=14,
	[I_D64S]=14,
	[I_R64U]=14,
	[I_R64S]=14,
	[I_LAD4]=14,
	[I_LAD5]=14,
	[I_LSU4]=14,
	[I_LSU5]=14,
	[I_LMU4]=14,
	[I_LMU5]=14,
	[I_LDI4]=14,
	[I_LDI5]=14,
	[I_LLS6]=14,
	[I_LLS7]=14,
	[I_LRS6]=14,
	[I_LRS7]=14,
	[I_SYRQ]=16,
	
	[I_SYDE]=0 // to ensure length of array is sufficient
};

uint32_t backendInstructionSize(const InstructionSingle* IS){
	if (IS->id==I_ALCR | IS->id==I_STOF | IS->id==I_ZNXB){
		switch (IS->id){
			case I_ALCR:return 4u+(((unsigned)IS->arg.BW.a_1&0xFF00u)!=0u)*2u;
			case I_STOF:return 8u+(((unsigned)IS->arg.BW.a_1&0xFF00u)!=0u)*2u;
			case I_ZNXB:return IS->arg.D.a_0;
			
			default:;// impossible to hit default
		}
	}
	return instruction_id_to_backend_size[IS->id];
}


uint8_t decompressInstruction(const uint8_t* byteCode,InstructionSingle* IS_parent);

uint32_t backendInstructionSizeFromByteCode(const uint8_t* byteCode){
	InstructionSingle IS;
	IS.id=byteCode[0];
	if (IS.id==I_ALCR | IS.id==I_STOF | IS.id==I_ZNXB){
		decompressInstruction(byteCode,&IS);
		switch (IS.id){
			case I_ALCR:return 4u+(((unsigned)IS.arg.BW.a_1&0xFF00u)!=0u)*2u;
			case I_STOF:return 8u+(((unsigned)IS.arg.BW.a_1&0xFF00u)!=0u)*2u;
			case I_ZNXB:return IS.arg.D.a_0;
			
			default:;// impossible to hit default
		}
	}
	return instruction_id_to_backend_size[IS.id];
}

#ifdef INCLUDE_BACKEND

// symVal includes symbolic calculations,JTEN, and location of related label for things like D32U
void backendInstructionWrite(uint8_t** byte,uint32_t symVal,uint16_t func_stack_size,uint8_t func_stack_initial,const InstructionSingle IS){
	uint16_t w;
	uint16_t word[7];
	uint16_t size=1;
	switch (IS.id){
		case I_NOP_:
		case I_JEND:
		case I_SYRE:
		case I_SYDE:
		case I_SYCB:
		case I_SYCW:
		case I_SYCD:
		case I_SYCL:
		case I_SYW0:
		case I_SYW1:
		case I_SYW2:
		case I_SYW3:
		case I_SYW4:
		case I_SYW5:
		case I_SYW6:
		case I_SYW7:
		case I_SYW8:
		case I_SYW9:
		case I_SBLW:
		case I_SBRW:
		case I_SYD0:
		case I_SYD1:
		case I_SYD2:
		case I_SYD3:
		case I_SYD4:
		case I_SYD5:
		case I_SYD6:
		case I_SYD7:
		case I_SYD8:
		case I_SYD9:
		case I_SBLD:
		case I_SBRD:
		case I_SYQ0:
		case I_SYQ1:
		case I_SYQ2:
		case I_SYQ3:
		case I_SYQ4:
		case I_SYQ5:
		case I_SYQ6:
		case I_SYQ7:
		case I_SYQ8:
		case I_SYQ9:
		case I_SBLQ:
		case I_SBRQ:
		case I_SCBW:
		case I_SCWD:
		case I_SCZD:
		case I_SCDQ:
		case I_SCZQ:
		case I_SCQD:
		case I_SCDW:
		case I_SCWB:
		case I_SCDB:
		case I_SCQB:
		case I_PHIS:
		case I_PHIE:
		case I_FCST:
		case I_FCEN:
		case I_NSNB:
		case I_LABL:
		return;
		
		case I_SYDB:*((*byte)++)=symVal;return;
		case I_BYTE:*((*byte)++)=IS.arg.B1.a_0;return;
		
		case I_PU1_:case I_PUA1:word[0]=0xF000u |((unsigned)IS.arg.B1.a_0&0xFu);break;
		case I_POP1:word[0]=0xF200u |((unsigned)IS.arg.B1.a_0&0xFu);break;
		case I_PU2_:case I_PUA2:word[0]=0xF100u | (((unsigned)IS.arg.B2.a_1&0xFu)<<4) | ((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_POP2:word[0]=0xF300u | (((unsigned)IS.arg.B2.a_1&0xFu)<<4) | ((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_MOV_:word[0]=0xF400u | (((unsigned)IS.arg.B2.a_1&0xFu)<<4) | ((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_BSWP:word[0]=0xF500u | (((unsigned)IS.arg.B2.a_1&0xFu)<<4) | ((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_SHFT:word[0]=0xF600u | (((unsigned)IS.arg.B2.a_1&0xFu)<<4) | ((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_MULS:word[0]=0xF700u | (((unsigned)IS.arg.B2.a_1&0xFu)<<4) | ((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_MULL:word[0]=0xF800u | (((unsigned)IS.arg.B2.a_1&0xFu)<<4) | ((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_DIVM:word[0]=0xF900u | (((unsigned)IS.arg.B2.a_1&0xFu)<<4) | ((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_CALL:word[0]=0xFA00u | (((unsigned)IS.arg.B2.a_1&0xFu)<<4) | ((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_MRBN:case I_MRBV:word[0]=0xFC00u | (((unsigned)IS.arg.B2.a_1&0xFu)<<4) | ((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_MWBN:case I_MWBV:word[0]=0xFD00u | (((unsigned)IS.arg.B2.a_1&0xFu)<<4) | ((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_JJMP:word[0]=0xFE00u | ((unsigned)IS.arg.BBD.a_0&0xFu) | (((unsigned)IS.arg.BBD.a_1&0xFu)<<4);break;
		case I_AJMP:word[0]=0xFE00u | (((unsigned)IS.arg.B2.a_1&0xFu)<<4) | ((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_RET_:word[0]=0xFB00u;break;
		case I_AND_:word[0]=0x4000u | (((unsigned)IS.arg.B3.a_2&0xFu)<<8) | (((unsigned)IS.arg.B3.a_1&0xFu)<<4) | ((unsigned)IS.arg.B3.a_0&0xFu);break;
		case I_OR__:word[0]=0x5000u | (((unsigned)IS.arg.B3.a_2&0xFu)<<8) | (((unsigned)IS.arg.B3.a_1&0xFu)<<4) | ((unsigned)IS.arg.B3.a_0&0xFu);break;
		case I_XOR_:word[0]=0x6000u | (((unsigned)IS.arg.B3.a_2&0xFu)<<8) | (((unsigned)IS.arg.B3.a_1&0xFu)<<4) | ((unsigned)IS.arg.B3.a_0&0xFu);break;
		case I_SSUB:word[0]=0x7000u | (((unsigned)IS.arg.B3.a_2&0xFu)<<8) | (((unsigned)IS.arg.B3.a_1&0xFu)<<4) | ((unsigned)IS.arg.B3.a_0&0xFu);break;
		case I_MRWN:case I_MRWV:word[0]=0x8000u | (((unsigned)IS.arg.B3.a_2&0xFu)<<8) | (((unsigned)IS.arg.B3.a_1&0xFu)<<4) | ((unsigned)IS.arg.B3.a_0&0xFu);break;
		case I_MWWN:case I_MWWV:word[0]=0x9000u | (((unsigned)IS.arg.B3.a_2&0xFu)<<8) | (((unsigned)IS.arg.B3.a_1&0xFu)<<4) | ((unsigned)IS.arg.B3.a_0&0xFu);break;
		case I_ADDN:word[0]=0xA000u | (((unsigned)IS.arg.B3.a_2&0xFu)<<8) | (((unsigned)IS.arg.B3.a_1&0xFu)<<4) | ((unsigned)IS.arg.B3.a_0&0xFu);break;
		case I_SUBN:word[0]=0xC000u | (((unsigned)IS.arg.B3.a_2&0xFu)<<8) | (((unsigned)IS.arg.B3.a_1&0xFu)<<4) | ((unsigned)IS.arg.B3.a_0&0xFu);break;
		case I_SUBC:word[0]=0xD000u | (((unsigned)IS.arg.B3.a_2&0xFu)<<8) | (((unsigned)IS.arg.B3.a_1&0xFu)<<4) | ((unsigned)IS.arg.B3.a_0&0xFu);break;
		case I_CJMP:word[0]=0xE000u | (((unsigned)IS.arg.B3.a_2&0xFu)<<8) | (((unsigned)IS.arg.B3.a_1&0xFu)<<4) | ((unsigned)IS.arg.B3.a_0&0xFu);break;
		
		case I_SYRB:word[0]=((((unsigned)symVal)&0xFFu)<<4)|((unsigned)IS.arg.B1.a_0&0xFu);break;
		case I_BL1_:word[0]=((((unsigned)IS.arg.B2.a_1)&0xFFu)<<4)|((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_STRN:case I_STRV:word[0]=0x2000u |(((((unsigned)IS.arg.B2.a_1)&0xFFu))<<4)|((unsigned)IS.arg.B2.a_0&0xFu);break;
		case I_STWN:case I_STWV:word[0]=0x3000u |(((((unsigned)IS.arg.B2.a_1)&0xFFu))<<4)|((unsigned)IS.arg.B2.a_0&0xFu);break;
		
		case I_SYDW:word[0]=symVal;break;
		case I_WORD:word[0]=IS.arg.W.a_0;break;
		
		case I_SYRW:
		word[0]=        (((unsigned)symVal&0xFFu  )<<4)|((unsigned)IS.arg.B1.a_0&0xFu);
		word[1]=0x1000u|(((unsigned)symVal&0xFF00u)>>4)|((unsigned)IS.arg.B1.a_0&0xFu);
		size=2;
		break;
		case I_RL1_:
		word[0]=        (((unsigned)IS.arg.BW.a_1&0xFFu  )<<4)|((unsigned)IS.arg.BW.a_0&0xFu);
		word[1]=0x1000u|(((unsigned)IS.arg.BW.a_1&0xFF00u)>>4)|((unsigned)IS.arg.BW.a_0&0xFu);
		size=2;
		break;
		case I_STPS:
		w=func_stack_size-IS.arg.BW.a_1;
		word[0]=         ((((unsigned)w)&0xFFu)<<4)|((unsigned)IS.arg.BW.a_0&0xFu);
		word[1]=0xA100u |(((unsigned)IS.arg.BW.a_0<<4)&0xF0u)|((unsigned)IS.arg.BW.a_0&0xFu);
		size=2;
		break;
		
		case I_JTEN:case I_SYDD:
		word[0]=symVal;
		word[1]=symVal >>16;
		size=2;
		break;
		case I_DWRD:
		word[0]=IS.arg.D.a_0;
		word[1]=IS.arg.D.a_0 >>16;
		size=2;
		break;
		case I_STPA:
		w=func_stack_size - IS.arg.BW.a_1;
		word[0]=        ((((unsigned)w)&0xFFu  )<<4)|((unsigned)IS.arg.BW.a_0&0xFu);
		word[1]=0x1000u|((((unsigned)w)&0xFF00u)>>4)|((unsigned)IS.arg.BW.a_0&0xFu);
		word[2]=0xA100u |(((unsigned)IS.arg.BW.a_0<<4)&0xF0u)|((unsigned)IS.arg.BW.a_0&0xFu);
		size=3;
		break;
		case I_ALOC:
		w=func_stack_size - func_stack_initial;
		word[0]=        (((unsigned)w&0xFFu  )<<4)|1u;
		word[1]=0x1000u|(((unsigned)w&0xFF00u)>>4)|1u;
		word[2]=0xFF01;
		size=3;
		break;
		case I_RL2_:
		word[0]=        (unsigned)((IS.arg.BBD.a_2&0xFFlu      )<< 4)|((unsigned)IS.arg.BW.a_0&0xFu);
		word[1]=        (unsigned)((IS.arg.BBD.a_2&0xFF0000lu  )>>12)|((unsigned)IS.arg.BW.a_1&0xFu);
		word[2]=0x1000u|(unsigned)((IS.arg.BBD.a_2&0xFF00lu    )>> 4)|((unsigned)IS.arg.BW.a_0&0xFu);
		word[3]=0x1000u|(unsigned)((IS.arg.BBD.a_2&0xFF000000lu)>>20)|((unsigned)IS.arg.BW.a_1&0xFu);
		size=4;
		break;
		case I_SYRD:
		word[0]=        (unsigned)((symVal&0xFFlu      )<< 4)|((unsigned)IS.arg.B2.a_0&0xFu);
		word[1]=        (unsigned)((symVal&0xFF0000lu  )>>12)|((unsigned)IS.arg.B2.a_1&0xFu);
		word[2]=0x1000u|(unsigned)((symVal&0xFF00lu    )>> 4)|((unsigned)IS.arg.B2.a_0&0xFu);
		word[3]=0x1000u|(unsigned)((symVal&0xFF000000lu)>>20)|((unsigned)IS.arg.B2.a_1&0xFu);
		size=4;
		break;
		case I_D32U:
		case I_R32U:
		case I_D32S:
		case I_R32S:
		word[0]=0x000Au;
		word[1]=0xF00Au;
		word[2]=0x000Au|(unsigned)((symVal&0xFFlu      )<< 4);
		word[3]=0x000Bu|(unsigned)((symVal&0xFF0000lu  )>>12);
		word[4]=0x100Au|(unsigned)((symVal&0xFF00lu    )>> 4);
		word[5]=0x100Bu|(unsigned)((symVal&0xFF000000lu)>>20);
		word[6]=0xFABAu;
		size=7;
		break;
		case I_D64U:
		case I_R64U:
		case I_D64S:
		case I_R64S:
		case I_LAD4:
		case I_LAD5:
		case I_LSU4:
		case I_LSU5:
		case I_LMU4:
		case I_LMU5:
		case I_LDI4:
		case I_LDI5:
		case I_LLS6:
		case I_LLS7:
		case I_LRS6:
		case I_LRS7:
		word[0]=0x0002u;
		word[1]=0xF002u;
		word[2]=0x0002u|(unsigned)((symVal&0xFFlu      )<< 4);
		word[3]=0x0003u|(unsigned)((symVal&0xFF0000lu  )>>12);
		word[4]=0x1002u|(unsigned)((symVal&0xFF00lu    )>> 4);
		word[5]=0x1003u|(unsigned)((symVal&0xFF000000lu)>>20);
		word[6]=0xFA32u;
		size=7;
		break;
		case I_ALCR:
		word[0]=(((unsigned)IS.arg.BW.a_1&0xFFu)<<4)|((unsigned)IS.arg.BW.a_0&0xFu);
		if ((((unsigned)IS.arg. BW.a_1&0xFF00u)!=0u)){
			word[1]=0x1000u|(((unsigned)IS.arg.BW.a_1&0xFF00u)>>4)|((unsigned)IS.arg.BW.a_0&0xFu);
			word[2]=0xFF00u|((unsigned)IS.arg.BW.a_0&0xFu);
			size=3;
		} else {
			word[1]=0xFF00u|((unsigned)IS.arg.BW.a_0&0xFu);
			size=2;
		}
		break;
		case I_STOF:
		word[0]=0x000Fu;
		word[1]=0xFF0Fu;
		w=(unsigned)IS.arg.BW.a_0&0xFu;
		word[2]=(((unsigned)IS.arg.BW.a_1&0xFFu)<<4)|w;
		if (((unsigned)IS.arg.BW.a_1&0xFF00u)!=0u){
			word[3]=0x1000u|(((unsigned)IS.arg.BW.a_1&0xFF00u)>>4)|w;
			word[4]=0xAF00u|(unsigned)w|((unsigned)w<<4);
			size=5;
		} else {
			word[3]=0xAF00u|(unsigned)w|((unsigned)w<<4);
			size=4;
		}
		break;
		case I_ZNXB:
		memset((*byte),0,IS.arg.D.a_0);
		(*byte)+=IS.arg.D.a_0;
		return;
		case I_LAD0:
		word[0]=0x000Fu;
		word[1]=0xB000u|(((unsigned)IS.arg.B6.a_4&0xFu)<<8)|(((unsigned)IS.arg.B6.a_2&0xFu)<<4)|((unsigned)IS.arg.B6.a_0&0xFu);
		word[2]=0xB000u|(((unsigned)IS.arg.B6.a_5&0xFu)<<8)|(((unsigned)IS.arg.B6.a_3&0xFu)<<4)|((unsigned)IS.arg.B6.a_1&0xFu);
		//Explanation: 0xB000u|(((unsigned) r2 &0xFu)<<8)|(((unsigned) r1 &0xFu)<<4)|((unsigned) r0 &0xFu);
		size=3;
		break;
		case I_LAD1:
		word[0]=0x000Fu;
		word[1]=0xB000u|(((unsigned)IS.arg.B5.a_4&0xFu)<<8)|(((unsigned)IS.arg.B5.a_2&0xFu)<<4)|((unsigned)IS.arg.B5.a_0&0xFu);
		word[2]=0xAF00u|(((unsigned)IS.arg.B5.a_3&0xFu)<<4)|((unsigned)IS.arg.B5.a_1&0xFu);
		size=3;
		break;
		case I_LAD2:
		word[0]=0x000Fu;
		word[1]=0xB000u|(((unsigned)IS.arg.B4.a_3&0xFu)<<8)|(((unsigned)IS.arg.B4.a_2&0xFu)<<4)|((unsigned)IS.arg.B4.a_0&0xFu);
		word[2]=0xF4F0u|((unsigned)IS.arg.B4.a_1&0xFu);
		size=3;
		break;
		case I_LSU0:
		word[0]=0x001Fu;
		word[1]=0x700Fu|(((unsigned)IS.arg.B4.a_2&0xFu)<<8)|(((unsigned)IS.arg.B4.a_0&0xFu)<<4);
		word[2]=0x700Fu|(((unsigned)IS.arg.B4.a_3&0xFu)<<8)|(((unsigned)IS.arg.B4.a_1&0xFu)<<4);
		size=3;
		break;
		case I_LAD3:
		word[0]=0x000Fu;
		word[1]=0xB000u|(((unsigned)IS.arg.B8.a_4&0xFu)<<8)|(((unsigned)IS.arg.B8.a_0&0xFu)<<4)|((unsigned)IS.arg.B8.a_0&0xFu);
		word[2]=0xB000u|(((unsigned)IS.arg.B8.a_5&0xFu)<<8)|(((unsigned)IS.arg.B8.a_1&0xFu)<<4)|((unsigned)IS.arg.B8.a_1&0xFu);
		word[3]=0xB000u|(((unsigned)IS.arg.B8.a_6&0xFu)<<8)|(((unsigned)IS.arg.B8.a_2&0xFu)<<4)|((unsigned)IS.arg.B8.a_2&0xFu);
		word[4]=0xB000u|(((unsigned)IS.arg.B8.a_7&0xFu)<<8)|(((unsigned)IS.arg.B8.a_3&0xFu)<<4)|((unsigned)IS.arg.B8.a_3&0xFu);
		size=5;
		break;
		default:;
		assert(false); // invalid operator id
		exit(1);
	}
	memcpy(*byte,word,size *2);
	*byte+=size *2;
}
#endif //ifdef INCLUDE_BACKEND

static uint8_t instruction_id_to_content_catagory[]={
	[I_NOP_]=0,
	[I_FCEN]=1,
	[I_RET_]=1,
	[I_ALOC]=1,
	[I_D32U]=1,
	[I_R32U]=1,
	[I_D32S]=1,
	[I_R32S]=1,
	[I_D64U]=1,
	[I_R64U]=1,
	[I_D64S]=1,
	[I_R64S]=1,
	[I_LAD4]=1,
	[I_LAD5]=1,
	[I_LSU4]=1,
	[I_LSU5]=1,
	[I_LMU4]=1,
	[I_LMU5]=1,
	[I_LDI4]=1,
	[I_LDI5]=1,
	[I_LLS6]=1,
	[I_LLS7]=1,
	[I_LRS6]=1,
	[I_LRS7]=1,
	[I_JEND]=1,
	[I_SYRE]=1,
	[I_SYDB]=1,
	[I_SYDW]=1,
	[I_SYDD]=1,
	[I_SYDQ]=1,
	[I_SYDE]=1,
	[I_SYW0]=1,
	[I_SYW1]=1,
	[I_SYW2]=1,
	[I_SYW3]=1,
	[I_SYW4]=1,
	[I_SYW5]=1,
	[I_SYW6]=1,
	[I_SYW7]=1,
	[I_SYW8]=1,
	[I_SYW9]=1,
	[I_SBLW]=1,
	[I_SBRW]=1,
	[I_SYD0]=1,
	[I_SYD1]=1,
	[I_SYD2]=1,
	[I_SYD3]=1,
	[I_SYD4]=1,
	[I_SYD5]=1,
	[I_SYD6]=1,
	[I_SYD7]=1,
	[I_SYD8]=1,
	[I_SYD9]=1,
	[I_SBLD]=1,
	[I_SBRD]=1,
	[I_SYQ0]=1,
	[I_SYQ1]=1,
	[I_SYQ2]=1,
	[I_SYQ3]=1,
	[I_SYQ4]=1,
	[I_SYQ5]=1,
	[I_SYQ6]=1,
	[I_SYQ7]=1,
	[I_SYQ8]=1,
	[I_SYQ9]=1,
	[I_SBLQ]=1,
	[I_SBRQ]=1,
	[I_SCBW]=1,
	[I_SCWD]=1,
	[I_SCZD]=1,
	[I_SCDQ]=1,
	[I_SCZQ]=1,
	[I_SCQD]=1,
	[I_SCDW]=1,
	[I_SCWB]=1,
	[I_SCDB]=1,
	[I_SCQB]=1,
	[I_PU1_]=2,
	[I_PUA1]=2,
	[I_POP1]=2,
	[I_SYRB]=2,
	[I_SYRW]=2,
	[I_PHIS]=2,
	[I_PHIE]=2,
	[I_BYTE]=3,
	[I_SYCB]=3,
	[I_PU2_]=4,
	[I_PUA2]=4,
	[I_POP2]=4,
	[I_CALL]=4,
	[I_AJMP]=4,
	[I_MULS]=4,
	[I_MULL]=4,
	[I_DIVM]=4,
	[I_SHFT]=4,
	[I_BSWP]=4,
	[I_MWBN]=4,
	[I_MRBN]=4,
	[I_MWBV]=4,
	[I_MRBV]=4,
	[I_MOV_]=4,
	[I_SYRD]=4,
	[I_AND_]=5,
	[I_OR__]=5,
	[I_XOR_]=5,
	[I_SSUB]=5,
	[I_ADDN]=5,
	[I_SUBN]=5,
	[I_SUBC]=5,
	[I_MWWN]=5,
	[I_MRWN]=5,
	[I_MWWV]=5,
	[I_MRWV]=5,
	[I_CJMP]=5,
	[I_BL1_]=6,
	[I_STWN]=6,
	[I_STRN]=6,
	[I_STWV]=6,
	[I_STRV]=6,
	[I_WORD]=7,
	[I_SYCW]=7,
	[I_RL1_]=8,
	[I_ALCR]=8,
	[I_STPA]=8,
	[I_STPS]=8,
	[I_STOF]=8,
	[I_LABL]=9,
	[I_JTEN]=9,
	[I_SYCD]=9,
	[I_SYCL]=9,
	[I_DWRD]=9,
	[I_NSNB]=9,
	[I_ZNXB]=9,
	[I_RL2_]=10,
	[I_JJMP]=10,
	[I_FCST]=11,
	[I_LAD2]=12,
	[I_SYRQ]=12,
	[I_LSU0]=12,
	[I_LAD1]=13,
	[I_LAD0]=14,
	[I_LAD3]=15,
	[I_LSU3]=15,
	[I_LMU3]=15
};

// for compressed instruction buffers
uint8_t instructionContentCatagory(enum InstructionTypeID id){
	return instruction_id_to_content_catagory[id];
}

#ifndef IGNORE_NONBACKEND
#define INIT_INSTRUCTION_BUFFER_SIZE 1024

void initInstructionBuffer(InstructionBuffer* ib){
	memset(ib,0,sizeof(InstructionBuffer));
	ib->numberOfSlotsAllocated = INIT_INSTRUCTION_BUFFER_SIZE;
	ib->buffer = cosmic_malloc(ib->numberOfSlotsAllocated*sizeof(InstructionSingle));
}

void destroyInstructionBuffer(InstructionBuffer* ib){
	cosmic_free(ib->buffer);
	ib->buffer = NULL;
	ib->numberOfSlotsTaken = 0;
	ib->numberOfSlotsAllocated = 0;
}

void addInstruction(InstructionBuffer* ib, const InstructionSingle instructionSingle){
	if (ib->numberOfSlotsTaken>=ib->numberOfSlotsAllocated){
		assert(ib->numberOfSlotsAllocated!=0); // Cannot add instruction to destroyed instruction buffer
		ib->numberOfSlotsAllocated*=2;
		ib->buffer = cosmic_realloc(ib->buffer,ib->numberOfSlotsAllocated*sizeof(InstructionSingle));
	}
	ib->buffer[ib->numberOfSlotsTaken++]=instructionSingle;
}
#endif // #ifndef IGNORE_NONBACKEND

struct {
	const char* corruptionErrorMessage;
	FILE* binaryFile;
} binaryFileLoadState = {0};

// gets the next character from the currently open binary fle and ensures it is not EOF
uint8_t binaryFile_noEOF_fgetc(){
	int v;
	if ((v=fgetc(binaryFileLoadState.binaryFile))==EOF) err_10_1_(binaryFileLoadState.corruptionErrorMessage);
	return (uint8_t)v;
}

// ensures the next call to fgetc on the currently open binary file will give the EOF
void binaryFile_isEOF_fgetc(){
	if (fgetc(binaryFileLoadState.binaryFile)!=EOF) err_10_1_(binaryFileLoadState.corruptionErrorMessage);
}


// returns the delta
uint8_t decompressInstruction(const uint8_t* byteCode,InstructionSingle* IS_parent){
	uint8_t delta=0;
	InstructionSingle IS;
	switch (instructionContentCatagory(IS.id=byteCode[0])){
		case 0:
		delta=0;
		break;
		case 1:
		delta=1;
		break;
		case 2:
		IS.arg.B1.a_0=byteCode[1]&15;
		delta=2;
		break;
		case 3:
		IS.arg.B1.a_0=byteCode[1];
		delta=2;
		break;
		case 4:
		IS.arg.B2.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B2.a_1=(unsigned)byteCode[1]/16u;
		delta=2;
		break;
		case 5:
		IS.arg.B3.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B3.a_1=(unsigned)byteCode[1]/16u;
		IS.arg.B3.a_2=(unsigned)byteCode[2]&15u;
		delta=3;
		break;
		case 6:
		IS.arg.B2.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B2.a_1=byteCode[2];
		delta=3;
		break;
		case 7:
		IS.arg.W.a_0=(unsigned)byteCode[1]|(unsigned)byteCode[2]*256u;
		delta=3;
		break;
		case 8:
		IS.arg.BW.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.BW.a_1=(unsigned)byteCode[2]|(unsigned)byteCode[3]*256u;
		delta=4;
		break;
		case 9:
		IS.arg.D.a_0=
		(uint32_t)((unsigned)byteCode[1]|(unsigned)byteCode[2]*256u)|
		(uint32_t)((unsigned)byteCode[3]|(unsigned)byteCode[4]*256u)*65536lu;
		delta=5;
		break;
		case 10:
		IS.arg.BBD.a_0=(uint16_t)byteCode[1]&15u;
		IS.arg.BBD.a_1=(uint16_t)byteCode[1]/16u;
		IS.arg.BBD.a_2=
		(uint32_t)((unsigned)byteCode[2]|(unsigned)byteCode[3]*256u)|
		(uint32_t)((unsigned)byteCode[4]|(unsigned)byteCode[5]*256u)*65536lu;
		delta=6;
		break;
		case 11:
		IS.arg.BWD.a_0=byteCode[1];
		IS.arg.BWD.a_1=(unsigned)byteCode[2]|(unsigned)byteCode[3]*256u;
		IS.arg.BWD.a_2=
		(uint32_t)((unsigned)byteCode[4]|(unsigned)byteCode[5]*256u)|
		(uint32_t)((unsigned)byteCode[6]|(unsigned)byteCode[7]*256u)*65536lu;
		delta=8;
		break;
		case 12:
		IS.arg.B4.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B4.a_1=(unsigned)byteCode[1]/16u;
		IS.arg.B4.a_2=(unsigned)byteCode[2]&15u;
		IS.arg.B4.a_3=(unsigned)byteCode[2]/16u;
		delta=3;
		break;
		case 13:
		IS.arg.B5.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B5.a_1=(unsigned)byteCode[1]/16u;
		IS.arg.B5.a_2=(unsigned)byteCode[2]&15u;
		IS.arg.B5.a_3=(unsigned)byteCode[2]/16u;
		IS.arg.B5.a_4=(unsigned)byteCode[3]&15u;
		delta=4;
		break;
		case 14:
		IS.arg.B6.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B6.a_1=(unsigned)byteCode[1]/16u;
		IS.arg.B6.a_2=(unsigned)byteCode[2]&15u;
		IS.arg.B6.a_3=(unsigned)byteCode[2]/16u;
		IS.arg.B6.a_4=(unsigned)byteCode[3]&15u;
		IS.arg.B6.a_5=(unsigned)byteCode[3]/16u;
		delta=4;
		break;
		case 15:
		IS.arg.B8.a_0=(unsigned)byteCode[1]&15u;
		IS.arg.B8.a_1=(unsigned)byteCode[1]/16u;
		IS.arg.B8.a_2=(unsigned)byteCode[2]&15u;
		IS.arg.B8.a_3=(unsigned)byteCode[2]/16u;
		IS.arg.B8.a_4=(unsigned)byteCode[3]&15u;
		IS.arg.B8.a_5=(unsigned)byteCode[3]/16u;
		IS.arg.B8.a_6=(unsigned)byteCode[4]&15u;
		IS.arg.B8.a_7=(unsigned)byteCode[4]/16u;
		delta=5;
		break;
	}
	*IS_parent=IS;
	return delta;
}

#ifndef IGNORE_NONBACKEND

InstructionBuffer decompressInstructionBufferOnLoad(){
	InstructionBuffer ib;
	initInstructionBuffer(&ib);
	while (true){
		uint8_t byteCode[8];
		InstructionSingle IS;
		IS.id=(byteCode[0]=binaryFile_noEOF_fgetc());
		if (byteCode[0]==0) return ib;
		uint8_t icc = instructionContentCatagory(IS.id);
		static uint8_t icc_to_delta[] = {[0]=0,[1]=1,[2]=2,[3]=2,[4]=2,[5]=3,[6]=3,[7]=3,[8]=4,[9]=5,[10]=6,[11]=8,[12]=3,[13]=4,[14]=4,[15]=5};
		const uint8_t delta=icc_to_delta[icc];
		for (uint8_t deltaTemp=1;deltaTemp<delta;deltaTemp++){
			byteCode[deltaTemp]=binaryFile_noEOF_fgetc();
		}
		decompressInstruction(byteCode,&IS);
		addInstruction(&ib,IS);
	}
}


void printInstructionBufferWithMessageAndNumber(const InstructionBuffer*,const char*,const uint32_t);
void printSingleInstructionOptCode(const InstructionSingle);


// decompressInstructionBuffer() expects validity and the terminating zero
InstructionBuffer decompressInstructionBuffer(const uint8_t* byteCodeStart){
	InstructionBuffer ib;
	initInstructionBuffer(&ib);
	const uint8_t* byteCode=byteCodeStart;
	uint32_t i=0;
	while (byteCode[i]){
		InstructionSingle IS;
		i+=decompressInstruction(byteCode+i,&IS);
		addInstruction(&ib,IS);
	}
	return ib;
}

void ensureInstructionBufferSize(InstructionBuffer* ib,uint32_t size){
	if (size>=ib->numberOfSlotsAllocated){
		do {
			ib->numberOfSlotsAllocated*=2;
		} while (size>=ib->numberOfSlotsAllocated);
		ib->buffer=cosmic_realloc(ib->buffer,ib->numberOfSlotsAllocated*sizeof(InstructionSingle));
	}
}

// the first is modified, the second is not
void singleMergeIB(InstructionBuffer* ib0, const InstructionBuffer* ib1){
	ensureInstructionBufferSize(ib0,ib0->numberOfSlotsTaken+ib1->numberOfSlotsTaken);
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib1->buffer,ib1->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib1->numberOfSlotsTaken;
}

void dualMergeIB(InstructionBuffer* ib0,const InstructionBuffer* ib1,const InstructionBuffer* ib2){
	ensureInstructionBufferSize(ib0,ib0->numberOfSlotsTaken+ib1->numberOfSlotsTaken+ib2->numberOfSlotsTaken);
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib1->buffer,ib1->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib1->numberOfSlotsTaken;
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib2->buffer,ib2->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib2->numberOfSlotsTaken;
}

void tripleMergeIB(InstructionBuffer* ib0,const InstructionBuffer* ib1,const InstructionBuffer* ib2,const InstructionBuffer* ib3){
	ensureInstructionBufferSize(ib0,ib0->numberOfSlotsTaken+ib1->numberOfSlotsTaken+ib2->numberOfSlotsTaken+ib3->numberOfSlotsTaken);
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib1->buffer,ib1->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib1->numberOfSlotsTaken;
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib2->buffer,ib2->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib2->numberOfSlotsTaken;
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib3->buffer,ib3->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib3->numberOfSlotsTaken;
}

void quadMergeIB(InstructionBuffer* ib0,const InstructionBuffer* ib1,const InstructionBuffer* ib2,const InstructionBuffer* ib3,const InstructionBuffer* ib4){
	ensureInstructionBufferSize(ib0,ib0->numberOfSlotsTaken+ib1->numberOfSlotsTaken+ib2->numberOfSlotsTaken+ib3->numberOfSlotsTaken+ib4->numberOfSlotsTaken);
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib1->buffer,ib1->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib1->numberOfSlotsTaken;
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib2->buffer,ib2->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib2->numberOfSlotsTaken;
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib3->buffer,ib3->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib3->numberOfSlotsTaken;
	memcpy(ib0->buffer+ib0->numberOfSlotsTaken,ib4->buffer,ib4->numberOfSlotsTaken*sizeof(InstructionSingle));
	ib0->numberOfSlotsTaken+=ib4->numberOfSlotsTaken;
}


// returns the delta
// assumes that the space is avalible in byteCode
uint8_t compressInstruction(uint8_t* byteCode,const InstructionSingle IS){
	switch (instructionContentCatagory(byteCode[0]=IS.id)){
		case 0:
		return 0;
		case 1:
		return 1;
		case 2:
		case 3:
		byteCode[1]=IS.arg.B1.a_0;
		return 2;
		case 4:
		byteCode[1]=IS.arg.B2.a_0|(IS.arg.B2.a_1*16);
		return 2;
		case 5:
		byteCode[1]=IS.arg.B3.a_0|(IS.arg.B3.a_1*16);
		byteCode[2]=IS.arg.B3.a_2;
		return 3;
		case 6:
		byteCode[1]=IS.arg.B2.a_0;
		byteCode[2]=IS.arg.B2.a_1;
		return 3;
		case 7:
		byteCode[1]=IS.arg.W.a_0&255;
		byteCode[2]=((unsigned)IS.arg.W.a_0&(255U*256U))/256U;
		return 3;
		case 8:
		byteCode[1]=IS.arg.BW.a_0;
		byteCode[2]=IS.arg.BW.a_1&255;
		byteCode[3]=((unsigned)IS.arg.BW.a_1&(255U*256U))/256U;
		return 4;
		case 9:
		byteCode[1]=IS.arg.D.a_0&255;
		byteCode[2]=((unsigned)IS.arg.D.a_0&(255U*256U))/256U;
		byteCode[3]=*((uint16_t*)&IS.arg.D.a_0+1)&255U;
		byteCode[4]=(*((uint16_t*)&IS.arg.D.a_0+1)&(255U*256U))/256U;
		return 5;
		case 10:
		byteCode[1]=IS.arg.BBD.a_0|(IS.arg.BBD.a_1*16);
		byteCode[2]=(unsigned)IS.arg.BBD.a_2&255U;
		byteCode[3]=((unsigned)IS.arg.BBD.a_2&(255U*256U))/256U;
		byteCode[4]=*((uint16_t*)&IS.arg.BBD.a_2+1)&255U;
		byteCode[5]=(*((uint16_t*)&IS.arg.BBD.a_2+1)&(255U*256U))/256U;
		return 6;
		case 11:
		byteCode[1]=IS.arg.BWD.a_0;
		byteCode[2]=IS.arg.BWD.a_1&255;
		byteCode[3]=((unsigned)IS.arg.BWD.a_1&(255U*256U))/256U;
		byteCode[4]=IS.arg.BWD.a_2&255;
		byteCode[5]=((unsigned)IS.arg.BWD.a_2&(255U*256U))/256U;
		byteCode[6]=*((uint16_t*)&IS.arg.BWD.a_2+1)&255U;
		byteCode[7]=(*((uint16_t*)&IS.arg.BWD.a_2+1)&(255U*256U))/256U;
		return 8;
		case 12:
		byteCode[1]=IS.arg.B4.a_0|(IS.arg.B4.a_1*16);
		byteCode[2]=IS.arg.B4.a_2|(IS.arg.B4.a_3*16);
		return 3;
		case 13:
		byteCode[1]=IS.arg.B5.a_0|(IS.arg.B5.a_1*16);
		byteCode[2]=IS.arg.B5.a_2|(IS.arg.B5.a_3*16);
		byteCode[3]=IS.arg.B5.a_4;
		return 4;
		case 14:
		byteCode[1]=IS.arg.B6.a_0|(IS.arg.B6.a_1*16);
		byteCode[2]=IS.arg.B6.a_2|(IS.arg.B6.a_3*16);
		byteCode[3]=IS.arg.B6.a_4|(IS.arg.B6.a_5*16);
		return 4;
		case 15:
		byteCode[1]=IS.arg.B8.a_0|(IS.arg.B8.a_1*16);
		byteCode[2]=IS.arg.B8.a_2|(IS.arg.B8.a_3*16);
		byteCode[3]=IS.arg.B8.a_4|(IS.arg.B8.a_5*16);
		byteCode[4]=IS.arg.B8.a_6|(IS.arg.B8.a_7*16);
		return 5;
	}
	assert(false);
	exit(1);
}

uint8_t getStorageDeltaForInstruction(enum InstructionTypeID id){
	// if something changes, do not just change this, there are other places
	static const uint8_t deltas[]={
		[ 0]=0,[ 1]=1,[ 2]=2,[ 3]=2,[ 4]=2,[ 5]=3,[ 6]=3,[ 7]=3,[ 8]=4,[ 9]=5,[10]=6,[11]=8,[12]=3,[13]=4,[14]=4,[15]=5
	};
	return deltas[instructionContentCatagory(id)];
}

CompressedInstructionBuffer compressInstructionBuffer(const InstructionBuffer* ib){
	CompressedInstructionBuffer cib;
	cib.allocLen=1;
	uint32_t numberOfSlotsTaken=ib->numberOfSlotsTaken;
	for (uint32_t i=0;i<numberOfSlotsTaken;i++){
		cib.allocLen+=getStorageDeltaForInstruction(ib->buffer[i].id);
	}
	cib.byteCode=cosmic_malloc(cib.allocLen*sizeof(uint8_t));
	uint8_t* byteCode=cib.byteCode;
	for (uint32_t i=0;i<numberOfSlotsTaken;i++){
		byteCode+=compressInstruction(byteCode,ib->buffer[i]);
	}
	*byteCode=0;
	assert(cib.byteCode+(cib.allocLen-1)==byteCode);
	return cib;
}


struct InstructionBuffersOfFunctions{
	CompressedInstructionBuffer* slots;
	uint32_t numberOfSlotsAllocated;
	uint32_t numberOfSlotsTaken;
} globalInstructionBuffersOfFunctions;

// input is destroyed
void addEntryToInstructionBuffersOfFunctions(InstructionBuffer* ib){
	if (globalInstructionBuffersOfFunctions.numberOfSlotsTaken>=globalInstructionBuffersOfFunctions.numberOfSlotsAllocated){
		globalInstructionBuffersOfFunctions.numberOfSlotsAllocated+=100;
		globalInstructionBuffersOfFunctions.slots = cosmic_realloc(
			globalInstructionBuffersOfFunctions.slots,
			globalInstructionBuffersOfFunctions.numberOfSlotsAllocated*sizeof(InstructionBuffer));
	}
	CompressedInstructionBuffer cib=compressInstructionBuffer(ib);
	globalInstructionBuffersOfFunctions.slots[globalInstructionBuffersOfFunctions.numberOfSlotsTaken++]=cib;
	destroyInstructionBuffer(ib);
}

void applyLabelRenamesInAllCompressedInstructionBuffers(const uint32_t* fromArr,const uint32_t* toArr,const uint32_t arrLen){
	if (arrLen==0) return;
	for (uint32_t i0=0;i0<globalInstructionBuffersOfFunctions.numberOfSlotsTaken;i0++){
		uint8_t* byteCode=globalInstructionBuffersOfFunctions.slots[i0].byteCode;
		while (*byteCode!=0){
			bool didChange=false;
			enum InstructionTypeID id=*byteCode;
			InstructionSingle IS;
			uint8_t delta;
			if (id==I_LABL | id==I_SYCL | id==I_JTEN | id==I_FCST){
				delta=decompressInstruction(byteCode,&IS);
				for (uint32_t i1=0;i1<arrLen;i1++){
					if (IS.arg.D.a_0==fromArr[i1]){IS.arg.D.a_0=toArr[i1];didChange=true;break;}
				}
			} else if (id==I_JJMP){
				delta=decompressInstruction(byteCode,&IS);
				for (uint32_t i1=0;i1<arrLen;i1++){
					if (IS.arg.BBD.a_2==fromArr[i1]){IS.arg.BBD.a_2=toArr[i1];didChange=true;break;}
				}
			} else {
				delta=getStorageDeltaForInstruction(id);
			}
			if (didChange) compressInstruction(byteCode,IS);
			byteCode+=delta;
		}
	}
}

void applyLabelRenamesInInstructionBuffer(InstructionBuffer* ib,const uint32_t* fromArr,const uint32_t* toArr,const uint32_t arrLen){
	if (arrLen==0) return;
	uint32_t numberOfSlotsTaken=ib->numberOfSlotsTaken;
	InstructionSingle* buffer=ib->buffer;
	for (uint32_t i=0;i<numberOfSlotsTaken;i++){
		enum InstructionTypeID id=buffer[i].id;
		uint32_t lablVal;
		uint32_t* lablPtr;
		if (id==I_LABL | id==I_SYCL | id==I_JTEN | id==I_FCST){
			lablPtr=&buffer[i].arg.D.a_0;
			Search:;
			lablVal=*lablPtr;
			for (uint32_t i1=0;i1<arrLen;i1++){
				if (lablVal==fromArr[i1]){*lablPtr=toArr[i1];break;}
			}
		} else if (id==I_JJMP){
			lablPtr=&buffer[i].arg.BBD.a_2;
			goto Search;
		}
	}
}

// label markoffs do not check LABL or FCST
void doLabelMarkoffInAllCompressedInstructionBuffers(uint32_t* labelMarkoff,const uint32_t arrLen){
	if (arrLen==0) return;
	for (uint32_t i0=0;i0<globalInstructionBuffersOfFunctions.numberOfSlotsTaken;i0++){
		uint8_t* byteCode=globalInstructionBuffersOfFunctions.slots[i0].byteCode;
		while (*byteCode!=0){
			enum InstructionTypeID id=*byteCode;
			InstructionSingle IS;
			uint32_t lablVal;
			uint8_t delta;
			if (id==I_SYCL | id==I_JTEN){
				delta=decompressInstruction(byteCode,&IS);
				lablVal=IS.arg.D.a_0;
				Search:;
				for (uint32_t i1=0;i1<arrLen;i1++){
					if (lablVal==labelMarkoff[i1]){labelMarkoff[i1]=0;break;}
				}
			} else if (id==I_JJMP){
				delta=decompressInstruction(byteCode,&IS);
				lablVal=IS.arg.BBD.a_2;
				goto Search;
			} else {
				delta=getStorageDeltaForInstruction(id);
			}
			byteCode+=delta;
		}
	}
}

// label markoffs do not check LABL or FCST
void doLabelMarkoffInInstructionBuffer(const InstructionBuffer* ib,uint32_t* labelMarkoff,const uint32_t arrLen){
	if (arrLen==0) return;
	uint32_t numberOfSlotsTaken=ib->numberOfSlotsTaken;
	InstructionSingle* buffer=ib->buffer;
	for (uint32_t i=0;i<numberOfSlotsTaken;i++){
		enum InstructionTypeID id=buffer[i].id;
		uint32_t lablVal;
		if (id==I_SYCL | id==I_JTEN){
			lablVal=buffer[i].arg.D.a_0;
			Search:;
			for (uint32_t i1=0;i1<arrLen;i1++){
				if (lablVal==labelMarkoff[i1]){labelMarkoff[i1]=0;break;}
			}
		} else if (id==I_JJMP){
			lablVal=buffer[i].arg.BBD.a_2;
			goto Search;
		}
	}
}




// these functions that follow are to avoid using InstructionSingle in expressionToInstructions

void add_ALCR(InstructionBuffer* ib, uint16_t size){
	InstructionSingle IS;
	IS.id=I_ALCR;
	IS.arg.BW.a_0=11;
	IS.arg.BW.a_1=size;
	addInstruction(ib,IS);
}

void addVoidPop(InstructionBuffer* ib){
	InstructionSingle IS;
	IS.id=I_POP1;
	IS.arg.B1.a_0=3;
	addInstruction(ib,IS);
}

void addQuadVoidPop(InstructionBuffer* ib){
	addVoidPop(ib);
	addVoidPop(ib);
	addVoidPop(ib);
	addVoidPop(ib);
}

void addPopArgPush1(InstructionBuffer* ib){
	InstructionSingle IS;
	IS.id=I_POP1;
	IS.arg.B1.a_0=3;
	addInstruction(ib,IS);
	IS.id=I_PUA1;
	IS.arg.B1.a_0=3;
	addInstruction(ib,IS);
}

void addPopArgPush2(InstructionBuffer* ib){
	InstructionSingle IS;
	IS.id=I_POP2;
	IS.arg.B2.a_0=3;
	IS.arg.B2.a_1=4;
	addInstruction(ib,IS);
	IS.id=I_PUA2;
	IS.arg.B2.a_0=4;
	IS.arg.B2.a_1=3;
	addInstruction(ib,IS);
}


/*
addStructArgPush() is if isLValue==true
otherwise, this should not be called and the argument should be treated as pushed as an argument. 
I don't think the optimizer will have a problem with that.
*/
void addStructArgPush(InstructionBuffer* ib, uint16_t size, bool isVolatile){
	InstructionSingle IS;
	IS.id=I_POP2;
	IS.arg.B2.a_0=3;
	IS.arg.B2.a_1=4;
	addInstruction(ib,IS);
	while (size){
		size-=2;
		IS.id=I_RL1_;
		IS.arg.BW.a_0=6;
		IS.arg.BW.a_1=size;
		addInstruction(ib,IS);
		IS.id=I_LAD1;
		IS.arg.B5.a_0=7;
		IS.arg.B5.a_1=8;
		IS.arg.B5.a_2=3;
		IS.arg.B5.a_3=4;
		IS.arg.B5.a_4=6;
		addInstruction(ib,IS);
		if (isVolatile) IS.id=I_MRWV;
		else IS.id=I_MRWN;
		IS.arg.B3.a_0=5;
		IS.arg.B3.a_1=7;
		IS.arg.B3.a_2=8;
		addInstruction(ib,IS);
		IS.id=I_PUA1;
		IS.arg.B1.a_0=5;
		addInstruction(ib,IS);
	}
}



// pops an rvalue struct from the stack. should have address pushed after struct
// isVolatile obviously refers to the write operation.
// when it is finished, the original address is pushed back to the stack
void addStructStackAssign(InstructionBuffer* ib, uint16_t size, bool isVolatile){
	uint16_t initSize=size;
	InstructionSingle IS;
	IS.id=I_POP2;
	IS.arg.B2.a_0=3;
	IS.arg.B2.a_1=4;
	addInstruction(ib,IS);
	while (size){
		IS.id=I_POP1;
		IS.arg.B1.a_0=5;
		addInstruction(ib,IS);
		IS.id=I_RL1_;
		IS.arg.BW.a_0=6;
		IS.arg.BW.a_1=initSize-size;
		size-=2;
		addInstruction(ib,IS);
		IS.id=I_LAD1;
		IS.arg.B5.a_0=7;
		IS.arg.B5.a_1=8;
		IS.arg.B5.a_2=3;
		IS.arg.B5.a_3=4;
		IS.arg.B5.a_4=6;
		addInstruction(ib,IS);
		if (isVolatile) IS.id=I_MWWV;
		else IS.id=I_MWWN;
		IS.arg.B3.a_0=5;
		IS.arg.B3.a_1=7;
		IS.arg.B3.a_2=8;
		addInstruction(ib,IS);
	}
	IS.id=I_PU2_;
	IS.arg.B2.a_0=4;
	IS.arg.B2.a_1=3;
	addInstruction(ib,IS);
}


// for after an initializer finishes
void convertSTPI_STPA(InstructionBuffer* ib, uint16_t offsetToAdd){
	for (uint32_t i=0;i<ib->numberOfSlotsTaken;i++){
		if (ib->buffer[i].id==I_STPI){
			ib->buffer[i].id=I_STPA;
			uint16_t* vp=&ib->buffer[i].arg.BW.a_1;
			*vp=offsetToAdd-*vp;
		}
	}
}

#endif // #ifndef IGNORE_NONBACKEND
